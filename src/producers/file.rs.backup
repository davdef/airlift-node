use std::sync::Arc;
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::time::{SystemTime, UNIX_EPOCH};
use anyhow::Result;

pub struct FileProducer {
    name: String,
    running: Arc<AtomicBool>,
    samples_processed: Arc<AtomicU64>,
    config: crate::config::ProducerConfig,
    thread_handle: Option<std::thread::JoinHandle<()>>,
    ring_buffer: Option<Arc<crate::core::AudioRingBuffer>>,
}

impl FileProducer {
    pub fn new(name: &str, config: &crate::config::ProducerConfig) -> Self {
        Self {
            name: name.to_string(),
            running: Arc::new(AtomicBool::new(false)),
            samples_processed: Arc::new(AtomicU64::new(0)),
            config: config.clone(),
            thread_handle: None,
            ring_buffer: None,
        }
    }
    
    fn utc_ns_now() -> u64 {
        let d = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();
        d.as_secs() * 1_000_000_000 + d.subsec_nanos() as u64
    }
}

impl crate::core::Producer for FileProducer {
    fn name(&self) -> &str {
        &self.name
    }
    
    fn start(&mut self) -> Result<()> {
        let path = self.config.path.clone().unwrap_or_else(|| "default.wav".to_string());
        let loop_audio = self.config.loop_audio.unwrap_or(false);
        
        log::info!("FileProducer '{}': Starting (path: {}, loop: {})", 
            self.name, path, loop_audio);
        
        self.running.store(true, Ordering::SeqCst);
        
        let samples_processed = self.samples_processed.clone();
        let running = self.running.clone();
        let name = self.name.clone();
        let ring_buffer = self.ring_buffer.clone();
        
        std::thread::spawn(move || {
            log::info!("FileProducer '{}': Playing {}", name, path);
            
            // Simuliere Audio-Daten
            let sample_rate = 48000;
            let channels = 2;
            let target_frames = sample_rate as usize / 10; // 100ms
            let target_samples = target_frames * channels;
            
            let mut tick = 0;
            while running.load(Ordering::Relaxed) {
                std::thread::sleep(std::time::Duration::from_millis(100));
                tick += 1;
                
                samples_processed.fetch_add(100, Ordering::Relaxed);
                
                // Alle 10 Ticks (1 Sekunde) einen Frame erzeugen
                if tick % 10 == 0 {
                    let chunk_samples = vec![0i16; target_samples];
                    
                    // In RingBuffer speichern
                    if let Some(rb) = &ring_buffer {
                        let frame = crate::core::PcmFrame {
                            utc_ns: crate::core::utc_ns_now(),
                            samples: chunk_samples,
                            sample_rate,
                            channels: channels as u8,
                        };
                        rb.push(frame);
                    }
                    
                    log::debug!("FileProducer '{}': Generated frame", name);
                }
            }
            
            log::info!("FileProducer '{}': Stopped", name);
        });
        
        Ok(())
    }
    
    fn stop(&mut self) -> Result<()> {
        log::info!("FileProducer '{}': Stopping...", self.name);
        self.running.store(false, Ordering::SeqCst);
        Ok(())
    }
    
    fn status(&self) -> crate::core::ProducerStatus {
        crate::core::ProducerStatus {
            running: self.running.load(Ordering::Relaxed),
            connected: true,
            samples_processed: self.samples_processed.load(Ordering::Relaxed),
            errors: 0,
            buffer_stats: self.ring_buffer.as_ref().map(|b| b.stats()),
        }
    }
    
    fn attach_ring_buffer(&mut self, buffer: Arc<crate::core::AudioRingBuffer>) {
        self.ring_buffer = Some(buffer);
    }
}
