// src/audio/http.rs — Korrigierte Version

use std::io::{Read, Write};
use std::path::PathBuf;
use std::process::{Command, Stdio};
use std::sync::{
    atomic::{AtomicBool, Ordering},
    mpsc, Arc,
};
use std::thread;
use std::time::{Duration, Instant};

use log::{debug, error, info, warn};
use tiny_http::{Header, Method, Response, Server, StatusCode};

use crate::audio::timeshift::stream_timeshift;
use crate::ring::{RingRead, RingReader};

// ============================================================================
// Public entry
// ============================================================================

pub fn start_audio_http_server(
    bind: &str,
    wav_dir: PathBuf,
    ring_reader_factory: impl Fn() -> RingReader + Send + Sync + 'static,
) -> anyhow::Result<()> {
    let server = Server::http(bind)
        .map_err(|e| anyhow::anyhow!(e))?;

    let wav_dir = Arc::new(wav_dir);
    let ring_factory: Arc<dyn Fn() -> RingReader + Send + Sync> = Arc::new(ring_reader_factory);

    info!("[audio] HTTP server on {}", bind);

    thread::spawn(move || {
        for req in server.incoming_requests() {
            info!("[audio] incoming {} {}", req.method(), req.url());

            if req.method() != &Method::Get {
                let _ = req.respond(Response::empty(StatusCode(405)));
                continue;
            }

            if req.url().starts_with("/audio/at") {
                handle_timeshift(req, wav_dir.clone());
                continue;
            }

            if req.url().starts_with("/audio/live") {
                handle_live(req, ring_factory.clone());
                continue;
            }

            let _ = req.respond(Response::empty(StatusCode(404)));
        }
    });

    Ok(())
}

// ============================================================================
// Timeshift (OGG/Opus)
// ============================================================================

fn handle_timeshift(req: tiny_http::Request, wav_dir: Arc<PathBuf>) {
    let ts = match extract_ts(req.url()) {
        Some(ts) => ts,
        None => {
            let _ = req.respond(Response::from_string("missing ts").with_status_code(400));
            return;
        }
    };

    info!("[audio] timeshift start ts={}", ts);

    let stop = Arc::new(AtomicBool::new(false));
    let (tx, rx) = mpsc::channel::<Vec<u8>>();
    let reader = ChannelReader::new(rx, stop.clone());

    let response = Response::new(
        StatusCode(200),
        vec![
            Header::from_bytes("Content-Type", "audio/ogg; codecs=opus").unwrap(),
            Header::from_bytes("Cache-Control", "no-store, no-cache, must-revalidate").unwrap(),
            Header::from_bytes("Pragma", "no-cache").unwrap(),
            Header::from_bytes("Expires", "0").unwrap(),
            Header::from_bytes("Access-Control-Allow-Origin", "*").unwrap(),
        ],
        reader,
        None,
        None,
    );

    let supervisor = thread::spawn({
        let stop = stop.clone();
        move || {
            let mut ffmpeg = match spawn_ffmpeg_timeshift() {
                Some(p) => p,
                None => {
                    stop.store(true, Ordering::Relaxed);
                    return;
                }
            };

            let mut ff_stdin = ffmpeg.stdin.take().unwrap();
            let mut ff_stdout = ffmpeg.stdout.take().unwrap();

            let feeder = thread::spawn({
                let wav_dir = (*wav_dir).clone();
                let stop = stop.clone();
                move || {
                    let _ = stream_timeshift(wav_dir, ts, |pcm| {
                        if stop.load(Ordering::Relaxed) {
                            return Ok(());
                        }
                        ff_stdin.write_all(pcm)?;
                        Ok(())
                    });
                    drop(ff_stdin);
                    stop.store(true, Ordering::Relaxed);
                }
            });

            let tx_pump = tx.clone();
            let pumper = thread::spawn({
                let stop = stop.clone();
                move || {
                    pump_ffmpeg_stdout("timeshift", &mut ff_stdout, &tx_pump, &stop);
                    stop.store(true, Ordering::Relaxed);
                }
            });

            while !stop.load(Ordering::Relaxed) {
                thread::sleep(Duration::from_millis(20));
            }

            let _ = ffmpeg.kill();
            let _ = ffmpeg.wait();
            let _ = feeder.join();
            let _ = pumper.join();
            drop(tx);
        }
    });

    if req.respond(response).is_err() {
        stop.store(true, Ordering::Relaxed);
    }

    drop(supervisor);
}

// ============================================================================
// Live — Jetzt auch OGG/Opus (konsistent mit Timeshift)
// ============================================================================

fn handle_live(req: tiny_http::Request, ring_factory: Arc<dyn Fn() -> RingReader + Send + Sync>) {
    info!("[audio] live start");

    let stop = Arc::new(AtomicBool::new(false));
    let (tx, rx) = mpsc::channel::<Vec<u8>>();
    let reader = ChannelReader::new(rx, stop.clone());

    let response = Response::new(
        StatusCode(200),
        vec![
            Header::from_bytes("Content-Type", "audio/ogg; codecs=opus").unwrap(),
            Header::from_bytes("Cache-Control", "no-store, no-cache, must-revalidate").unwrap(),
            Header::from_bytes("Pragma", "no-cache").unwrap(),
            Header::from_bytes("Expires", "0").unwrap(),
            Header::from_bytes("Access-Control-Allow-Origin", "*").unwrap(),
        ],
        reader,
        None,
        None,
    );

    let supervisor = thread::spawn({
        let stop = stop.clone();
        move || {
            let mut ffmpeg = match spawn_ffmpeg_live() {
                Some(p) => p,
                None => {
                    stop.store(true, Ordering::Relaxed);
                    return;
                }
            };

            let mut ff_stdin = ffmpeg.stdin.take().unwrap();
            let mut ff_stdout = ffmpeg.stdout.take().unwrap();

            let feeder = thread::spawn({
                let stop = stop.clone();
                move || {
                    let mut ring = ring_factory();
                    let mut buffer = Vec::new();

                    while !stop.load(Ordering::Relaxed) {
                        match ring.poll() {
                            RingRead::Chunk(slot) => {
                                let bytes = bytemuck::cast_slice::<i16, u8>(&slot.pcm);
                                buffer.extend_from_slice(bytes);
                                
                                // Sende in sinnvollen Blöcken (z.B. 4096 Samples = 8192 Bytes)
                                if buffer.len() >= 8192 {
                                    if ff_stdin.write_all(&buffer).is_err() {
                                        break;
                                    }
                                    buffer.clear();
                                }
                            }
                            RingRead::Empty => {
                                // Keine Daten, kurze Pause
                                thread::sleep(Duration::from_millis(1));
                            }
                            RingRead::Gap { missed } => {
                                warn!("[audio] live GAP missed={}", missed);
                                // Bei Lücke einfach weitermachen statt zu stoppen
                                thread::sleep(Duration::from_millis(10));
                            }
                        }
                    }

                    // Restliche Daten senden
                    if !buffer.is_empty() {
                        let _ = ff_stdin.write_all(&buffer);
                    }
                    
                    drop(ff_stdin);
                }
            });

            let tx_pump = tx.clone();
            let pumper = thread::spawn({
                let stop = stop.clone();
                move || {
                    pump_ffmpeg_stdout("live", &mut ff_stdout, &tx_pump, &stop);
                    stop.store(true, Ordering::Relaxed);
                }
            });

            while !stop.load(Ordering::Relaxed) {
                thread::sleep(Duration::from_millis(20));
            }

            let _ = ffmpeg.kill();
            let _ = ffmpeg.wait();
            let _ = feeder.join();
            let _ = pumper.join();
            drop(tx);
        }
    });

    if req.respond(response).is_err() {
        stop.store(true, Ordering::Relaxed);
    }

    drop(supervisor);
}

// ============================================================================
// ffmpeg für Live-Stream (OGG/Opus)
// ============================================================================

fn spawn_ffmpeg_live() -> Option<std::process::Child> {
    debug!("[audio] spawning ffmpeg for live");

    Command::new("ffmpeg")
        .args([
            "-loglevel", "error",
            "-f", "s16le",          // Raw PCM input
            "-ar", "48000",         // Sample rate
            "-ac", "2",             // Stereo
            "-i", "pipe:0",         // Read from stdin
            
            // Opus encoding parameters
            "-c:a", "libopus",
            "-application", "audio",
            "-frame_duration", "20",
            "-vbr", "off",
            "-b:a", "128k",
            
            // Output format
            "-f", "ogg",
            "pipe:1",               // Write to stdout
        ])
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()
        .map_err(|e| {
            error!("[audio] failed to spawn ffmpeg: {}", e);
            e
        })
        .ok()
}

// ============================================================================
// ffmpeg für Timeshift (OGG/Opus)
// ============================================================================

fn spawn_ffmpeg_timeshift() -> Option<std::process::Child> {
    debug!("[audio] spawning ffmpeg for timeshift");

    Command::new("ffmpeg")
        .args([
            "-loglevel", "error",
            "-f", "s16le",
            "-ar", "48000",
            "-ac", "2",
            "-i", "pipe:0",
            
            "-c:a", "libopus",
            "-application", "audio",
            "-frame_duration", "20",
            "-vbr", "off",
            "-b:a", "128k",
            
            "-f", "ogg",
            "pipe:1",
        ])
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()
        .ok()
}

// ============================================================================
// Pump + Reader (unverändert)
// ============================================================================

fn pump_ffmpeg_stdout(
    tag: &str,
    out: &mut impl Read,
    tx: &mpsc::Sender<Vec<u8>>,
    stop: &Arc<AtomicBool>,
) {
    let mut buf = [0u8; 8192];

    while !stop.load(Ordering::Relaxed) {
        match out.read(&mut buf) {
            Ok(0) => {
                info!("[audio] {} ffmpeg stdout EOF", tag);
                break;
            }
            Ok(n) => {
                if tx.send(buf[..n].to_vec()).is_err() {
                    info!("[audio] {} channel closed", tag);
                    break;
                }
            }
            Err(e) => {
                info!("[audio] {} read error: {}", tag, e);
                break;
            }
        }
    }

    info!("[audio] {} stdout ended", tag);
}

struct ChannelReader {
    rx: mpsc::Receiver<Vec<u8>>,
    pending: Vec<u8>,
    stop: Arc<AtomicBool>,
}

impl ChannelReader {
    fn new(rx: mpsc::Receiver<Vec<u8>>, stop: Arc<AtomicBool>) -> Self {
        Self {
            rx,
            pending: Vec::new(),
            stop,
        }
    }
}

impl Drop for ChannelReader {
    fn drop(&mut self) {
        self.stop.store(true, Ordering::Relaxed);
    }
}

impl Read for ChannelReader {
    fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {
        // Zuerst ausstehende Daten senden
        if !self.pending.is_empty() {
            let n = self.pending.len().min(buf.len());
            buf[..n].copy_from_slice(&self.pending[..n]);
            self.pending.drain(..n);
            return Ok(n);
        }

        if self.stop.load(Ordering::Relaxed) {
            return Ok(0); // EOF
        }

        match self.rx.recv_timeout(Duration::from_secs(1)) {
            Ok(chunk) => {
                let n = chunk.len().min(buf.len());
                buf[..n].copy_from_slice(&chunk[..n]);
                if n < chunk.len() {
                    self.pending.extend_from_slice(&chunk[n..]);
                }
                Ok(n)
            }
            Err(mpsc::RecvTimeoutError::Timeout) => {
                // Für Live-Stream: Weiter warten statt EOF
                if self.stop.load(Ordering::Relaxed) {
                    Ok(0)
                } else {
                    Err(std::io::ErrorKind::WouldBlock.into())
                }
            }
            Err(mpsc::RecvTimeoutError::Disconnected) => Ok(0),
        }
    }
}

fn extract_ts(url: &str) -> Option<u64> {
    url.split('?')
        .nth(1)?
        .split('&')
        .find_map(|p| {
            let mut it = p.split('=');
            (it.next()? == "ts").then(|| it.next()?.parse().ok()).flatten()
        })
}
