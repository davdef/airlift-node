async function initializeRingbuffer() {
    try {
        // 1. Hole Buffer-Status (EINMALIG)
        const status = await fetch('/api/status').then(r => r.json());
        const ring = status.ring;
        const capacity = ring.capacity || 6000;
        const headIndex = ring.head_index || 0;  // Wo schreibt er gerade?
        const tailIndex = ring.tail_index || 0;  // Wo liest er?
        
        // 2. Hole EXAKT 10min History (nicht 20!)
        // Das ist der gesamte sichtbare Buffer
        
        // Problem: Wir wissen nicht, welche Studiozeit zu welchem Chunk gehört
        // Aber: Wir können die neuesten 10min History laden
        
        const currentTime = latestStudioTime || Date.now();
        const bufferDuration = capacity * 100; // 10min in ms
        const historyStart = currentTime - bufferDuration;
        
        const response = await fetch(`/api/history?from=${historyStart}&to=${currentTime}`);
        if (response.ok) {
            const data = await response.json();
            const allPoints = data.map(normalizeHistoryPoint).filter(Boolean);
            
            // 3. JETZT das schwierige: Punkte auf Buffer-Positionen mappen
            
            // Annahme: Linearer Zeitverlauf
            // Jeder Chunk = 100ms
            // Position = ((Zeit - historyStart) / 100ms) mod capacity
            
            ringbufferData = new Array(capacity).fill(null).map(() => ({
                l: 0, r: 0, silence: false, age: 0
            }));
            
            allPoints.forEach(point => {
                // Relative Position in den 10min
                const timeFromStart = point.ts - historyStart;
                if (timeFromStart < 0 || timeFromStart > bufferDuration) return;
                
                const bufferPos = Math.floor(timeFromStart / 100) % capacity;
                
                // ABER: Buffer ist zyklisch! Head ist NICHT am Ende!
                // Wir müssen die Punkte rotieren, sodass Head am "Ende" ist
                
                // Rotiere: newPos = (pos - headIndex + capacity) % capacity
                const rotatedPos = (bufferPos - headIndex + capacity) % capacity;
                
                // Speichere mit Alter für Opacity
                const age = currentTime - point.ts; // 0-10min
                
                const left = point.peaks[0] || 0;
                const right = point.peaks[1] || 0;
                
                if (left > ringbufferData[rotatedPos].l) ringbufferData[rotatedPos].l = left;
                if (right > ringbufferData[rotatedPos].r) ringbufferData[rotatedPos].r = right;
                if (point.silence) ringbufferData[rotatedPos].silence = true;
                ringbufferData[rotatedPos].age = age;
            });
            
            console.log('Buffer loaded:', {
                capacity,
                headIndex,
                points: allPoints.length,
                oldest: Math.min(...allPoints.map(p => p.ts)),
                newest: Math.max(...allPoints.map(p => p.ts))
            });
            
            // 4. Zeichne EINMALIG
            drawRingbufferStatic();
        }
        
    } catch (error) {
        console.error('Buffer init failed:', error);
    }
}

function drawRingbufferStatic() {
    if (!ringbufferCtx || !ringbufferData) return;
    
    const width = ringbufferCanvas.width;
    const height = ringbufferCanvas.height;
    
    // Clear EINMAL
    ringbufferCtx.fillStyle = '#0d1117';
    ringbufferCtx.fillRect(0, 0, width, height);
    
    // Draw grid
    ringbufferCtx.strokeStyle = 'rgba(136, 136, 136, 0.1)';
    ringbufferCtx.lineWidth = 1;
    for (let i = 1; i < 10; i++) {
        const x = (width / 10) * i;
        ringbufferCtx.beginPath();
        ringbufferCtx.moveTo(x, 0);
        ringbufferCtx.lineTo(x, height);
        ringbufferCtx.stroke();
    }
    
    const midY = height / 2;
    const bufferDuration = 10 * 60 * 1000; // 10min
    
    // Zeichne alle Punkte mit Age-basierter Opacity
    for (let x = 0; x < width; x++) {
        const bufferIndex = Math.floor((x / width) * ringbufferData.length);
        const point = ringbufferData[bufferIndex];
        
        if (!point || (point.l === 0 && point.r === 0)) continue;
        
        // Opacity basierend auf Alter
        // Neu (0min) = 1.0, Alt (10min) = 0.3
        const opacity = 0.3 + (0.7 * (1 - point.age / bufferDuration));
        
        const leftHeight = Math.min(point.l * height * 0.45, height / 2);
        const rightHeight = Math.min(point.r * height * 0.45, height / 2);
        
        // Left channel
        ringbufferCtx.fillStyle = `rgba(90, 160, 255, ${opacity * 0.75})`;
        ringbufferCtx.fillRect(x, midY - leftHeight, 1, leftHeight);
        
        // Right channel
        ringbufferCtx.fillStyle = `rgba(155, 89, 182, ${opacity * 0.75})`;
        ringbufferCtx.fillRect(x, midY, 1, rightHeight);
        
        // Silence
        if (point.silence) {
            ringbufferCtx.fillStyle = `rgba(231, 76, 60, ${opacity * 0.25})`;
            ringbufferCtx.fillRect(x, 0, 1, height);
        }
    }
    
    // Zeiger anzeigen (Head ist rechts)
    const headX = width - 2; // Ganz rechts
    const overlay = document.getElementById('ringbufferOverlay');
    overlay.innerHTML = `<div class="waveform-marker head" style="left: ${headX}px;"></div>`;
}
