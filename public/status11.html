<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Airlift Audio Node</title>
    <style>
        :root {
            --bg: #0b0e11;
            --panel: #14171c;
            --panel-light: #1c2128;
            --blue: #5aa0ff;
            --blue-light: #8cc2ff;
            --text: #d8e4f0;
            --good: #2ecc71;
            --warn: #f1c40f;
            --bad: #e74c3c;
            --input: #3498db;
            --buffer: #9b59b6;
            --output: #27ae60;
            --codec: #e67e22;
            --service: #e84393;
            --processing: #f39c12;
            --wave-active: #5aa0ff;
            --wave-ghost: rgba(90, 160, 255, 0.3);
            --wave-bg: rgba(90, 160, 255, 0.1);
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            background: var(--bg);
            color: var(--text);
            font-family: system-ui, sans-serif;
            overflow-x: hidden;
        }

        /* HEADER --------------------------------------------------- */
        header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 16px;
            background: var(--panel);
            border-bottom: 1px solid #222;
        }

        header img {
            height: 36px;
            opacity: 0.95;
        }

        header h1 {
            font-size: 22px;
            font-weight: bold;
            color: #ffffff;
            font-weight: 500;
            text-transform: uppercase;
            margin: 0;
        }

        .header-meta {
            margin-left: auto;
            text-align: right;
            font-size: 12px;
        }

        .conn-status {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .conn-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #888;
        }

        .conn-dot.connected { background: var(--good); animation: pulse 2s infinite; }
        .conn-dot.error { background: var(--bad); }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .studio-time {
            font-family: monospace;
            font-size: 13px;
            color: var(--blue-light);
            margin-top: 2px;
        }

        /* MAIN LAYOUT ---------------------------------------------- */
        main {
            padding: 16px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            max-width: 1600px;
            margin: 0 auto;
        }

        @media (max-width: 1200px) {
            main {
                grid-template-columns: 1fr;
            }
        }

        /* PANELS --------------------------------------------------- */
        .panel {
            background: var(--panel);
            border: 1px solid #222;
            border-radius: 8px;
            overflow: hidden;
        }

        .panel-header {
            padding: 12px 16px;
            background: var(--panel-light);
            border-bottom: 1px solid #222;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .panel-title {
            margin: 0;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--blue-light);
        }

        .panel-content {
            padding: 16px;
        }

        /* AUDIO PIPELINE TREE -------------------------------------- */
        .pipeline-tree {
            grid-column: 1 / -1;
            min-height: 200px;
        }

        .tree-container {
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .tree-level {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            position: relative;
        }

        .tree-level:not(:last-child)::after {
            content: '';
            position: absolute;
            left: 50%;
            bottom: -15px;
            transform: translateX(-50%);
            width: 2px;
            height: 15px;
            background: linear-gradient(to bottom, var(--blue), transparent);
        }

        .level-label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
            align-self: flex-start;
            padding-left: 16px;
            position: relative;
        }

        .level-label::before {
            content: '';
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 10px;
            height: 2px;
            background: var(--blue);
        }

        .level-modules {
            display: flex;
            justify-content: center;
            gap: 15px;
            width: 100%;
        }

        /* MODULE CARDS -------------------------------------------- */
        .module-card {
            background: var(--panel-light);
            border: 2px solid;
            border-radius: 6px;
            padding: 14px;
            min-width: 180px;
            text-align: center;
            position: relative;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .module-card.input { border-color: var(--input); }
        .module-card.buffer { border-color: var(--buffer); }
        .module-card.output { border-color: var(--output); }
        .module-card.service { border-color: var(--service); }
        .module-card.processing { border-color: var(--processing); }

        .module-header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 10px;
        }

        .module-type {
            font-size: 10px;
            padding: 3px 8px;
            border-radius: 10px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .type-input { background: var(--input); color: white; }
        .type-buffer { background: var(--buffer); color: white; }
        .type-output { background: var(--output); color: white; }
        .type-service { background: var(--service); color: white; }
        .type-processing { background: var(--processing); color: white; }

        .module-status {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 11px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .status-dot.active { background: var(--good); }
        .status-dot.ready { background: var(--warn); }
        .status-dot.inactive { background: var(--bad); }
        .status-dot.standby { background: #888; }

        .module-title {
            font-weight: 600;
            font-size: 15px;
            margin-bottom: 4px;
        }

        .module-id {
            font-family: monospace;
            font-size: 10px;
            color: #888;
            margin-bottom: 10px;
        }

        .module-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #222;
            font-size: 11px;
        }

        .module-stat {
            display: flex;
            flex-direction: column;
        }

        .consumer-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            min-width: 200px;
        }

        .consumer-children {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .stat-label {
            font-size: 9px;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 2px;
        }

        .stat-value {
            font-weight: 600;
            font-family: monospace;
            font-size: 12px;
        }

        /* WAVEFORM VISUALIZATIONS -------------------------------- */
        .waveform-container {
            height: 140px;
            background: #0d1117;
            border-radius: 6px;
            border: 1px solid #222;
            position: relative;
            overflow: hidden;
            margin-bottom: 12px;
        }

        .waveform-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .waveform-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        .waveform-marker {
            position: absolute;
            top: -6px;
            bottom: -6px;
            width: 3px;
            transform: translateX(-50%);
            border-radius: 2px;
            z-index: 10;
        }

        .waveform-marker.head {
            background: #ffffff;
            box-shadow: 0 0 10px #ffffff;
        }

        .waveform-marker.tail {
            background: var(--warn);
            box-shadow: 0 0 10px var(--warn);
        }

        .waveform-time-display {
            position: absolute;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 4px 12px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            color: var(--text);
        }

        .waveform-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 8px;
            font-size: 11px;
        }

        .waveform-stat {
            background: var(--panel-light);
            padding: 8px;
            border-radius: 4px;
            border-left: 3px solid var(--blue);
        }

        .waveform-stat-label {
            color: #888;
            text-transform: uppercase;
            margin-bottom: 4px;
            font-size: 10px;
        }

        .waveform-stat-value {
            font-weight: 600;
            font-family: monospace;
            font-size: 14px;
        }

        .waveform-stat-sub {
            font-size: 10px;
            color: #888;
            margin-top: 2px;
        }

        /* TABLES -------------------------------------------------- */
        .compact-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .compact-table th {
            text-align: left;
            padding: 8px 12px;
            color: #888;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 10px;
            letter-spacing: 0.5px;
            border-bottom: 1px solid #222;
        }

        .compact-table td {
            padding: 8px 12px;
            border-bottom: 1px solid rgba(34, 34, 34, 0.5);
        }

        .compact-table tr:hover {
            background: rgba(255, 255, 255, 0.02);
        }

        /* CONTROLS ------------------------------------------------ */
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 8px;
        }

        button {
            padding: 8px 12px;
            font-size: 12px;
            border-radius: 6px;
            border: none;
            color: var(--bg);
            background: var(--blue);
            cursor: pointer;
            font-weight: 500;
            border: 1px solid var(--blue);
            transition: all 0.2s ease;
            text-align: center;
        }

        button:hover:not(:disabled) {
            background: var(--blue-light);
            border-color: var(--blue-light);
        }

        button.primary {
            background: var(--blue);
            color: var(--bg);
        }

        button.small {
            padding: 6px 10px;
            font-size: 11px;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* RECORDER INFO ------------------------------------------- */
        .recorder-files {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .file-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: var(--panel-light);
            border-radius: 4px;
            border: 1px solid #222;
        }

        .file-icon {
            width: 24px;
            height: 24px;
            background: rgba(90, 160, 255, 0.1);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--blue);
        }

        .file-info {
            flex: 1;
        }

        .file-name {
            font-weight: 600;
            font-size: 12px;
            margin-bottom: 2px;
        }

        .file-path {
            font-family: monospace;
            font-size: 10px;
            color: #888;
        }

        .file-size {
            font-size: 10px;
            color: var(--blue-light);
        }

        /* CODECS LIST --------------------------------------------- */
        .codecs-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .codec-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: var(--panel-light);
            border-radius: 4px;
            border: 1px solid #222;
        }

        .codec-status {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .codec-info {
            flex: 1;
        }

        .codec-name {
            font-weight: 600;
            font-size: 12px;
            margin-bottom: 2px;
        }

        .codec-details {
            font-family: monospace;
            font-size: 10px;
            color: #888;
        }

        /* EMPTY STATES -------------------------------------------- */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 30px 20px;
            text-align: center;
            color: #888;
        }

        .empty-state .icon {
            font-size: 24px;
            margin-bottom: 8px;
            opacity: 0.5;
        }

        .empty-state .message {
            font-size: 13px;
        }

        /* MESSAGE BAR --------------------------------------------- */
        .message-bar {
            position: fixed;
            bottom: 16px;
            right: 16px;
            background: var(--panel);
            border: 1px solid var(--blue);
            border-radius: 6px;
            padding: 10px 14px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            max-width: 300px;
            display: none;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .message-bar.show {
            display: block;
        }

        .message-bar.success {
            border-color: var(--good);
            background: rgba(46, 204, 113, 0.1);
        }

        .message-bar.error {
            border-color: var(--bad);
            background: rgba(231, 76, 60, 0.1);
        }

        .message-bar.warning {
            border-color: var(--warn);
            background: rgba(241, 196, 15, 0.1);
        }

        /* RESPONSIVE ---------------------------------------------- */
        @media (max-width: 768px) {
            main {
                padding: 12px;
                gap: 12px;
            }
            
            .level-modules {
                flex-direction: column;
                align-items: center;
            }
            
            .module-card {
                width: 100%;
                max-width: 250px;
            }
            
            .waveform-container {
                height: 100px;
            }
            
            .compact-table {
                font-size: 11px;
            }
            
            .compact-table th,
            .compact-table td {
                padding: 6px 8px;
            }
        }
    </style>
</head>
<body>
<header>
    <img src="rfm-logo.png" alt="RFM Logo">
    <h1>Airlift Audio Node</h1>
    <div class="header-meta">
        <div class="conn-status">
            <span class="conn-dot"></span>
            <span id="connText">Verbinde...</span>
        </div>
        <div class="studio-time" id="studioTime">‚Äì</div>
        <div style="font-size: 12px; color: #888;">
            Aktualisiert: <span id="updateTime">‚Äì</span>
        </div>
    </div>
</header>

<main>
    <!-- Audio Pipeline Tree -->
    <section class="panel pipeline-tree">
        <div class="panel-header">
            <h2 class="panel-title">Audio Pipeline</h2>
            <button class="btn small" onclick="fetchAllData()">‚Üª Aktualisieren</button>
        </div>
        <div class="tree-container" id="pipelineTree">
            <div class="empty-state">
                <div class="icon">üéµ</div>
                <div class="message">Lade Audio-Pipeline...</div>
            </div>
        </div>
    </section>

    <!-- Ringbuffer Visualization -->
    <section class="panel">
        <div class="panel-header">
            <h2 class="panel-title" id="ringbufferTitle">Ringbuffer</h2>
            <div style="font-size: 11px; color: #888;">
                <span id="ringbufferInfo">F√ºllstand: 0%</span>
            </div>
        </div>
        <div class="panel-content">
            <div class="waveform-container">
                <canvas class="waveform-canvas" id="ringbufferCanvas"></canvas>
                <div class="waveform-overlay" id="ringbufferOverlay"></div>
                <div class="waveform-time-display" id="ringbufferTime">‚Äì</div>
            </div>
            <div class="waveform-stats" id="ringbufferStats">
                <!-- Stats will be added here -->
            </div>
        </div>
    </section>

    <!-- Recorder WAV File -->
    <section class="panel">
        <div class="panel-header">
            <h2 class="panel-title">Recorder (1h WAV Datei)</h2>
            <div style="font-size: 11px; color: #888;">
                <span id="recorderProgress">0%</span>
            </div>
        </div>
        <div class="panel-content">
            <div class="waveform-container">
                <canvas class="waveform-canvas" id="recorderCanvas"></canvas>
                <div class="waveform-overlay" id="recorderOverlay"></div>
                <div class="waveform-time-display" id="recorderTime">‚Äì</div>
            </div>
            <div class="recorder-files" id="recorderFiles">
                <div class="empty-state">
                    <div class="icon">üìÅ</div>
                    <div class="message">Lade Recorder-Info...</div>
                </div>
            </div>
        </div>
    </section>

    <!-- Left Column -->
    <div style="display: flex; flex-direction: column; gap: 16px;">
        <!-- Active Modules -->
        <section class="panel">
            <div class="panel-header">
                <h2 class="panel-title">Aktive Module</h2>
                <span style="font-size: 11px; color: #888;" id="activeModulesCount">0</span>
            </div>
            <div class="panel-content">
                <table class="compact-table" id="modulesTable">
                    <thead>
                        <tr>
                            <th>Modul</th>
                            <th>Typ</th>
                            <th>Status</th>
                            <th>Datenrate</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td colspan="4" class="empty-state">
                                <div class="icon">üì¶</div>
                                <div class="message">Lade Module...</div>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <!-- Available Modules -->
        <section class="panel">
            <div class="panel-header">
                <h2 class="panel-title">Verf√ºgbare Module</h2>
                <span style="font-size: 11px; color: #888;" id="inactiveModulesCount">0</span>
            </div>
            <div class="panel-content">
                <table class="compact-table" id="inactiveModulesTable">
                    <thead>
                        <tr>
                            <th>Modul</th>
                            <th>Typ</th>
                            <th>Status</th>
                            <th>Grund</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td colspan="4" class="empty-state">
                                <div class="icon">üîå</div>
                                <div class="message">Keine inaktiven Module</div>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>
    </div>

    <!-- Right Column -->
    <div style="display: flex; flex-direction: column; gap: 16px;">
        <!-- Controls -->
        <section class="panel">
            <div class="panel-header">
                <h2 class="panel-title">Steuerung</h2>
            </div>
            <div class="panel-content">
                <div class="controls-grid" id="controlsGrid">
                    <button class="btn" disabled>Lade...</button>
                </div>
            </div>
        </section>

        <!-- Codecs -->
        <section class="panel">
            <div class="panel-header">
                <h2 class="panel-title">Verf√ºgbare Codecs</h2>
            </div>
            <div class="panel-content">
                <div class="codecs-list" id="codecsList">
                    <div class="empty-state">
                        <div class="icon">üîä</div>
                        <div class="message">Lade Codecs...</div>
                    </div>
                </div>
            </div>
        </section>

        <!-- System Status -->
        <section class="panel">
            <div class="panel-header">
                <h2 class="panel-title">System Status</h2>
            </div>
            <div class="panel-content">
                <div class="waveform-stats">
                    <div class="waveform-stat">
                        <div class="waveform-stat-label">Studio-Zeit</div>
                        <div class="waveform-stat-value" id="systemStudioTime">‚Äì</div>
                        <div class="waveform-stat-sub">Sendezeit aus Studio</div>
                    </div>
                    <div class="waveform-stat">
                        <div class="waveform-stat-label">Latenz</div>
                        <div class="waveform-stat-value" id="systemLatency">‚Äì</div>
                        <div class="waveform-stat-sub">Verz√∂gerung</div>
                    </div>
                    <div class="waveform-stat">
                        <div class="waveform-stat-label">Peaks Buffer</div>
                        <div class="waveform-stat-value" id="systemPeaksBuffer">‚Äì</div>
                        <div class="waveform-stat-sub">100ms Punkte</div>
                    </div>
                    <div class="waveform-stat">
                        <div class="waveform-stat-label">Audio Buffer</div>
                        <div class="waveform-stat-value" id="systemAudioBuffer">‚Äì</div>
                        <div class="waveform-stat-sub">Sekunden</div>
                    </div>
                </div>
            </div>
        </section>
    </div>
</main>

<div id="messageBar" class="message-bar"></div>

<script>
// State
let currentStatus = null;
let latestStudioTime = null;
let websocket = null;
const rateHistory = new Map();
let peaksMeta = null;
let ringbufferHistory = [];
let recorderHistory = [];
let ringbufferEndTime = null;
let recorderEndTime = null;
let wsMessageCount = 0;
const ringbufferConfig = {
    chunkMs: 100,
};

// Canvas setup
const ringbufferCanvas = document.getElementById('ringbufferCanvas');
const ringbufferCtx = ringbufferCanvas.getContext('2d');
const recorderCanvas = document.getElementById('recorderCanvas');
const recorderCtx = recorderCanvas.getContext('2d');

// Animation state
let animationFrameId = null;
let lastDrawTime = 0;
const DRAW_INTERVAL = 100; // 100ms zwischen Canvas-Updates

// Initialize canvases
function initCanvases() {
    const ringbufferContainer = ringbufferCanvas.parentElement;
    ringbufferCanvas.width = ringbufferContainer.clientWidth;
    ringbufferCanvas.height = ringbufferContainer.clientHeight;
    
    const recorderContainer = recorderCanvas.parentElement;
    recorderCanvas.width = recorderContainer.clientWidth;
    recorderCanvas.height = recorderContainer.clientHeight;
}

window.addEventListener('resize', initCanvases);

// Animation loop
function drawLoop() {
    const now = Date.now();
    if (now - lastDrawTime >= DRAW_INTERVAL) {
        if (currentStatus) {
            drawRingbuffer(currentStatus);
            drawRecorder(currentStatus);
        }
        lastDrawTime = now;
    }
    animationFrameId = requestAnimationFrame(drawLoop);
}

// Helper functions
function showMessage(text, type = 'info') {
    const bar = document.getElementById('messageBar');
    bar.textContent = text;
    bar.className = `message-bar show ${type}`;
    
    setTimeout(() => {
        bar.className = 'message-bar';
    }, 3000);
}

function updateConnectionState(connected) {
    const dot = document.querySelector('.conn-dot');
    const text = document.getElementById('connText');
    
    if (connected) {
        dot.className = 'conn-dot connected';
        text.textContent = 'Verbunden';
    } else {
        dot.className = 'conn-dot error';
        text.textContent = 'Getrennt';
    }
}

function formatTime(ms) {
    if (!ms) return '‚Äì';
    const date = new Date(ms);
    return date.toLocaleTimeString('de-DE', {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
    });
}

function formatDuration(ms) {
    if (!ms) return '0s';
    const seconds = Math.floor(ms / 1000);
    if (seconds < 60) return `${seconds}s`;
    const minutes = Math.floor(seconds / 60);
    return `${minutes}m ${seconds % 60}s`;
}

function normalizeHistoryPoint(point) {
    if (!point) return null;
    const ts = point.ts || point.timestamp;
    if (!ts) return null;
    return {
        ts,
        peaks: point.peaks || [point.peak_l || 0, point.peak_r || 0],
        silence: Boolean(point.silence)
    };
}

function calculateRate(moduleId, currentCounters, timestamp) {
    if (!rateHistory.has(moduleId)) {
        rateHistory.set(moduleId, {
            timestamp,
            counters: currentCounters
        });
        return { rx: '‚Äì', tx: '‚Äì' };
    }
    
    const prev = rateHistory.get(moduleId);
    const timeDiff = Math.max(1, timestamp - prev.timestamp);
    
    const rxRate = Math.round((currentCounters.rx - prev.counters.rx) * 60000 / timeDiff);
    const txRate = Math.round((currentCounters.tx - prev.counters.tx) * 60000 / timeDiff);
    
    rateHistory.set(moduleId, {
        timestamp,
        counters: currentCounters
    });
    
    return {
        rx: rxRate.toLocaleString(),
        tx: txRate.toLocaleString()
    };
}

function getModuleStatus(runtime) {
    if (!runtime.enabled) return { class: 'inactive', label: 'Aus', text: 'Deaktiviert' };
    if (!runtime.running) return { class: 'standby', label: 'Bereit', text: 'Bereit' };
    if (runtime.connected === false) return { class: 'ready', label: 'Bereit', text: 'Getrennt' };
    return { class: 'active', label: 'Aktiv', text: 'Aktiv' };
}

function getNodeStatus(node, moduleSnapshot) {
    if (moduleSnapshot) {
        return getModuleStatus(moduleSnapshot.runtime);
    }
    if (node.kind === 'service') {
        return { class: 'active', label: 'Service', text: 'Service' };
    }
    if (node.kind === 'processing') {
        return { class: 'standby', label: 'Codec', text: 'Codec' };
    }
    return { class: 'standby', label: 'Aktiv', text: 'Aktiv' };
}

function formatNodeId(nodeId) {
    if (nodeId.startsWith('service:')) return nodeId.replace('service:', '');
    if (nodeId.startsWith('codec:')) return nodeId.replace('codec:', '');
    return nodeId;
}

function buildRingbufferLayers(history, ring, endTime, width) {
    const capacity = ring.capacity || 6000;
    const headIndex = ring.head_index || 0;
    const tailIndex = ring.tail_index || 0;
    const chunkMs = ringbufferConfig.chunkMs;
    
    // Zwei separate Layers f√ºr aktuelle und vergangene Daten
    const currentLayer = Array.from({ length: width }, () => ({ l: 0, r: 0, silence: false }));
    const pastLayer = Array.from({ length: width }, () => ({ l: 0, r: 0, silence: false }));
    
    // Bereiche im Buffer definieren
    const bufferSize = capacity * chunkMs; // Gesamtgr√∂√üe in ms (10min)
    
    history.forEach(point => {
        const ts = point.ts;
        if (!ts) return;
        
        // Alter des Punktes relativ zum Endzeitpunkt
        const ageMs = endTime - ts;
        
        // Ignoriere zu alte Daten (> 20min)
        if (ageMs < 0 || ageMs >= bufferSize * 2) return;
        
        // Bestimme, in welchem Bereich der Punkt liegt:
        // - "Aktuell": 0-10min alt (gerade beschrieben oder von voriger Runde)
        // - "Vergangen": 10-20min alt (voriger Buffer-Durchlauf)
        
        const bufferOffset = Math.floor(ageMs / chunkMs);
        let bufferIndex = ((headIndex - bufferOffset) % capacity + capacity) % capacity;
        
        // Bestimme x-Position im Canvas (0-100%)
        const x = Math.min(width - 1, Math.max(0, Math.floor((bufferIndex / capacity) * width)));
        
        // W√§hle Layer basierend auf Alter
        const layer = ageMs < bufferSize ? currentLayer : pastLayer;
        
        // Update Peaks
        const left = point.peaks[0] || 0;
        const right = point.peaks[1] || 0;
        
        if (left > layer[x].l) layer[x].l = left;
        if (right > layer[x].r) layer[x].r = right;
        if (point.silence) layer[x].silence = true;
    });
    
    return { currentLayer, pastLayer };
}

function drawWaveformLayer(ctx, layer, height, colors) {
    const midY = height / 2;
    
    // Verwende Paths statt einzelner Rect-Aufrufe f√ºr bessere Performance
    let leftPath = new Path2D();
    let rightPath = new Path2D();
    
    for (let x = 0; x < layer.length; x++) {
        const point = layer[x];
        if (!point || (point.l === 0 && point.r === 0)) continue;
        
        const leftHeight = Math.min(point.l * height * 0.45, height / 2);
        const rightHeight = Math.min(point.r * height * 0.45, height / 2);
        
        leftPath.rect(x, midY - leftHeight, 1, leftHeight);
        rightPath.rect(x, midY, 1, rightHeight);
    }
    
    ctx.fillStyle = colors.left;
    ctx.fill(leftPath);
    
    ctx.fillStyle = colors.right;
    ctx.fill(rightPath);
    
    // Silence Overlay (nur wenn n√∂tig)
    ctx.fillStyle = colors.silence;
    for (let x = 0; x < layer.length; x++) {
        if (layer[x]?.silence) {
            ctx.fillRect(x, 0, 1, height);
        }
    }
}

// Draw Ringbuffer Waveform (Zyklischer Buffer)
function drawRingbuffer(status) {
    if (!ringbufferCtx || !status.ring) return;
    
    const width = ringbufferCanvas.width;
    const height = ringbufferCanvas.height;
    const ring = status.ring;
    
    // Clear canvas
    ringbufferCtx.fillStyle = '#0d1117';
    ringbufferCtx.fillRect(0, 0, width, height);
    
    const capacity = ring.capacity || 6000;
    const fillPercent = Math.round(ring.fill_ratio * 100);
    const headPos = ring.head_index || 0;
    const tailPos = ring.tail_index || 0;
    const chunkMs = ringbufferConfig.chunkMs;
    const bufferDurationMs = capacity * chunkMs;
    
    const endTime = ringbufferEndTime || latestStudioTime || Date.now();
    
    // Update info display
    document.getElementById('ringbufferInfo').textContent = `F√ºllstand: ${fillPercent}%`;
    document.getElementById('ringbufferTitle').textContent = `Ringbuffer (${capacity} Chunks / ${Math.round(bufferDurationMs / 60000)}min)`;
    
    // Draw grid
    ringbufferCtx.strokeStyle = 'rgba(136, 136, 136, 0.1)';
    ringbufferCtx.lineWidth = 1;
    
    // Vertical lines (Zeitmarker f√ºr 10min)
    for (let i = 1; i < 10; i++) {
        const x = (width / 10) * i;
        ringbufferCtx.beginPath();
        ringbufferCtx.moveTo(x, 0);
        ringbufferCtx.lineTo(x, height);
        ringbufferCtx.stroke();
    }
    
    if (ringbufferHistory.length > 0) {
        const { currentLayer, pastLayer } = buildRingbufferLayers(ringbufferHistory, ring, endTime, width);
        
        // 1. Zeichne vergangene Layer (opacity 0.3)
        drawWaveformLayer(ringbufferCtx, pastLayer, height, {
            left: 'rgba(90, 160, 255, 0.3)',
            right: 'rgba(155, 89, 182, 0.3)',
            silence: 'rgba(231, 76, 60, 0.1)'
        });
        
        // 2. Zeichne aktuelle Layer (opacity 0.75)
        drawWaveformLayer(ringbufferCtx, currentLayer, height, {
            left: 'rgba(90, 160, 255, 0.75)',
            right: 'rgba(155, 89, 182, 0.75)',
            silence: 'rgba(231, 76, 60, 0.25)'
        });
    }
    
    // Update markers overlay
    const overlay = document.getElementById('ringbufferOverlay');
    overlay.innerHTML = '';
    
    if (capacity > 0) {
        // Head marker (Schreibposition)
        const headMarkerX = (headPos / capacity) * width;
        const headMarker = document.createElement('div');
        headMarker.className = 'waveform-marker head';
        headMarker.style.left = `${headMarkerX}px`;
        headMarker.title = `Head: ${headPos}`;
        overlay.appendChild(headMarker);
        
        // Tail marker (Leseposition)
        if (tailPos !== headPos) {
            const tailMarkerX = (tailPos / capacity) * width;
            const tailMarker = document.createElement('div');
            tailMarker.className = 'waveform-marker tail';
            tailMarker.style.left = `${tailMarkerX}px`;
            tailMarker.title = `Tail: ${tailPos}`;
            overlay.appendChild(tailMarker);
        }
    }
    
    // Update time display
    const timeDisplay = document.getElementById('ringbufferTime');
    if (endTime) {
        const bufferStart = endTime - bufferDurationMs;
        timeDisplay.textContent = `${formatTime(bufferStart)} - ${formatTime(endTime)}`;
    } else {
        timeDisplay.textContent = '‚Äì';
    }
    
    // Update stats
    const statsContainer = document.getElementById('ringbufferStats');
    statsContainer.innerHTML = `
        <div class="waveform-stat">
            <div class="waveform-stat-label">F√ºllstand</div>
            <div class="waveform-stat-value">${fillPercent}%</div>
            <div class="waveform-stat-sub">${ring.fill || 0} / ${capacity}</div>
        </div>
        <div class="waveform-stat">
            <div class="waveform-stat-label">Zeitfenster</div>
            <div class="waveform-stat-value">${Math.round(bufferDurationMs / 60000)}min</div>
            <div class="waveform-stat-sub">${chunkMs}ms pro Chunk</div>
        </div>
        <div class="waveform-stat">
            <div class="waveform-stat-label">Head</div>
            <div class="waveform-stat-value">${headPos}</div>
            <div class="waveform-stat-sub">Schreibposition (E)</div>
        </div>
        <div class="waveform-stat">
            <div class="waveform-stat-label">Tail</div>
            <div class="waveform-stat-value">${tailPos}</div>
            <div class="waveform-stat-sub">Leseposition</div>
        </div>
        <div class="waveform-stat">
            <div class="waveform-stat-label">Sequenzen</div>
            <div class="waveform-stat-value">${ring.head_seq || 0}</div>
            <div class="waveform-stat-sub">Buffer-Durchl√§ufe</div>
        </div>
    `;
}

function buildRecorderLayer(history, hourStart, hourEnd, width) {
    const layer = Array.from({ length: width }, () => ({ l: 0, r: 0, silence: false }));
    const span = hourEnd - hourStart;
    if (span <= 0) return layer;
    history.forEach(point => {
        if (point.ts < hourStart || point.ts > hourEnd) return;
        const x = Math.min(width - 1, Math.max(0, Math.floor(((point.ts - hourStart) / span) * width)));
        const left = point.peaks[0] || 0;
        const right = point.peaks[1] || 0;
        if (left > layer[x].l) layer[x].l = left;
        if (right > layer[x].r) layer[x].r = right;
        if (point.silence) layer[x].silence = true;
    });
    return layer;
}

// Draw Recorder WAV File (1h Datei)
function drawRecorder(status) {
    if (!recorderCtx || !status.recorder) return;
    
    const width = recorderCanvas.width;
    const height = recorderCanvas.height;
    const recorder = status.recorder;
    
    // Clear canvas
    recorderCtx.fillStyle = '#0d1117';
    recorderCtx.fillRect(0, 0, width, height);
    
    // Aktuelle Stunde berechnen (Unix-Stunde)
    const currentHour = Math.floor(Date.now() / 1000 / 3600);
    const hourStart = currentHour * 3600 * 1000;
    const hourEnd = hourStart + 3600 * 1000;
    const now = recorderEndTime || latestStudioTime || Date.now();
    
    // Fortschritt in der aktuellen Stunde
    const progress = Math.min(1, Math.max(0, (now - hourStart) / 3600000));
    const progressPercent = Math.round(progress * 100);
    
    // Update progress display
    document.getElementById('recorderProgress').textContent = `${progressPercent}%`;
    
    // Draw grid (1h mit 6x 10min Segmenten)
    recorderCtx.strokeStyle = 'rgba(136, 136, 136, 0.2)';
    recorderCtx.lineWidth = 1;
    
    for (let i = 1; i < 6; i++) {
        const x = (width / 6) * i;
        recorderCtx.beginPath();
        recorderCtx.moveTo(x, 0);
        recorderCtx.lineTo(x, height);
        recorderCtx.stroke();
    }
    
    // Draw filled portion (bereits geschriebener Teil)
    const filledWidth = width * progress;
    
    if (filledWidth > 0) {
        // Filled background
        recorderCtx.fillStyle = 'rgba(39, 174, 96, 0.15)';
        recorderCtx.fillRect(0, 0, filledWidth, height);
        
        if (recorderHistory.length > 0) {
            const layer = buildRecorderLayer(recorderHistory, hourStart, hourEnd, width);
            recorderCtx.save();
            recorderCtx.beginPath();
            recorderCtx.rect(0, 0, filledWidth, height);
            recorderCtx.clip();
            drawWaveformLayer(recorderCtx, layer, height, {
                left: 'rgba(39, 174, 96, 0.8)',
                right: 'rgba(46, 204, 113, 0.8)',
                silence: 'rgba(231, 76, 60, 0.2)'
            });
            recorderCtx.restore();
        }
        
        // Write pointer (aktuelle Schreibposition)
        recorderCtx.strokeStyle = '#ffffff';
        recorderCtx.lineWidth = 2;
        recorderCtx.beginPath();
        recorderCtx.moveTo(filledWidth, 0);
        recorderCtx.lineTo(filledWidth, height);
        recorderCtx.stroke();
        
        // Write pointer head
        recorderCtx.fillStyle = '#ffffff';
        recorderCtx.beginPath();
        recorderCtx.arc(filledWidth, height / 2, 4, 0, Math.PI * 2);
        recorderCtx.fill();
    }
    
    // Empty portion (noch nicht geschrieben)
    if (filledWidth < width) {
        recorderCtx.fillStyle = 'rgba(136, 136, 136, 0.05)';
        recorderCtx.fillRect(filledWidth, 0, width - filledWidth, height);
    }
    
    // Update time display
    const timeDisplay = document.getElementById('recorderTime');
    const hourDate = new Date(hourStart);
    const hourStr = hourDate.getHours().toString().padStart(2, '0');
    timeDisplay.textContent = `Stunde ${hourStr}:00 - ${formatTime(hourStart)} ‚Üí ${formatTime(hourEnd)}`;
    
    // Update files list
    const filesContainer = document.getElementById('recorderFiles');
    if (recorder.current_files && recorder.current_files.length > 0) {
        filesContainer.innerHTML = recorder.current_files.map(file => {
            const fileName = file.split('/').pop();
            const fileSize = 'WAV';
            
            return `
                <div class="file-item">
                    <div class="file-icon">üéµ</div>
                    <div class="file-info">
                        <div class="file-name">${fileName}</div>
                        <div class="file-path">${file}</div>
                    </div>
                    <div class="file-size">${fileSize}</div>
                </div>
            `;
        }).join('');
    } else {
        filesContainer.innerHTML = '<div style="color: #888; font-style: italic;">Keine aktiven WAV-Dateien</div>';
    }
}

// WebSocket f√ºr Studio-Zeitupdates
function setupWebSocket() {
    const proto = location.protocol === 'https:' ? 'wss://' : 'ws://';
    const wsUrl = proto + window.location.host + '/ws';
    
    websocket = new WebSocket(wsUrl);
    
    websocket.onopen = () => {
        console.log('[WS] Verbunden');
        updateConnectionState(true);
    };
    
    websocket.onerror = (err) => {
        console.error('[WS] Fehler:', err);
        updateConnectionState(false);
    };
    
    websocket.onclose = () => {
        console.warn('[WS] Getrennt');
        updateConnectionState(false);
    };
    
    websocket.onmessage = (e) => {
        try {
            const data = JSON.parse(e.data);
            if (data && typeof data.timestamp === 'number') {
                wsMessageCount += 1;
                latestStudioTime = data.timestamp;
                
                // Update Studio-Zeit im Header
                const studioTimeElement = document.getElementById('studioTime');
                studioTimeElement.textContent = formatTime(latestStudioTime);
                
                // Update System Status
                const systemStudioTime = document.getElementById('systemStudioTime');
                systemStudioTime.textContent = formatTime(latestStudioTime);
                
                const systemLatency = document.getElementById('systemLatency');
                const latency = Date.now() - latestStudioTime;
                systemLatency.textContent = `${Math.max(0, latency)}ms`;

                if (wsMessageCount % 10 === 0) {
                    fetchAllData();
                }
            }
        } catch (err) {
            console.warn('[WS] Parse error:', err);
        }
    };
}

// Render Audio Pipeline
function renderAudioPipeline(status) {
    const container = document.getElementById('pipelineTree');
    
    if (!status.graph || !status.graph.nodes || status.graph.nodes.length === 0) {
        container.innerHTML = `
            <div class="empty-state">
                <div class="icon">üîá</div>
                <div class="message">Keine aktiven Module</div>
            </div>`;
        return;
    }
    
    const nodes = status.graph.nodes || [];
    const edges = status.graph.edges || [];
    const modulesById = new Map((status.modules || []).map(module => [module.id, module]));
    const edgesByFrom = new Map();

    edges.forEach(edge => {
        if (!edgesByFrom.has(edge.from)) {
            edgesByFrom.set(edge.from, []);
        }
        edgesByFrom.get(edge.from).push(edge.to);
    });

    const inputs = nodes.filter(node => node.kind === 'input');
    const buffers = nodes.filter(node => node.kind === 'buffer');
    
    let pipelineHTML = '';
    
    if (inputs.length > 0) {
        pipelineHTML += `
            <div class="tree-level">
                <div class="level-label">Input</div>
                <div class="level-modules">
                    ${inputs.map(node => renderPipelineNode(node, modulesById)).join('')}
                </div>
            </div>
            <div style="text-align: center; color: var(--blue); font-size: 20px; margin: 4px 0;">‚Üì</div>`;
    }
    
    if (buffers.length > 0) {
        pipelineHTML += `
            <div class="tree-level">
                <div class="level-label">Ringbuffer</div>
                <div class="level-modules">
                    ${buffers.map(node => renderPipelineNode(node, modulesById)).join('')}
                </div>
            </div>
            <div style="text-align: center; color: var(--blue); font-size: 20px; margin: 4px 0;">‚Üì</div>`;
    }
    
    if (buffers.length > 0) {
        const consumerGroups = buffers.flatMap(buffer => {
            const targets = edgesByFrom.get(buffer.id) || [];
            return targets.map(targetId => {
                const node = nodes.find(n => n.id === targetId);
                if (!node) return '';
                if (node.kind === 'processing') {
                    const downstream = edgesByFrom.get(node.id) || [];
                    const outputs = downstream
                        .map(outputId => nodes.find(n => n.id === outputId))
                        .filter(Boolean);
                    return renderConsumerGroup(node, outputs, modulesById);
                }
                return renderConsumerGroup(node, [], modulesById);
            });
        }).filter(Boolean);

        pipelineHTML += `
            <div class="tree-level">
                <div class="level-label">Konsumenten (Module & Services)</div>
                <div class="level-modules">
                    ${consumerGroups.join('')}
                </div>
            </div>`;
    }
    
    container.innerHTML = pipelineHTML;
}

function renderPipelineNode(node, modulesById) {
    const moduleSnapshot = modulesById.get(node.id);
    const statusInfo = getNodeStatus(node, moduleSnapshot);
    const type = node.kind;
    
    return `
        <div class="module-card ${type}">
            <div class="module-header">
                <span class="module-type type-${type}">${type}</span>
                <span class="module-status">
                    <span class="status-dot ${statusInfo.class}"></span>
                    <span>${statusInfo.label}</span>
                </span>
            </div>
            <div class="module-title">${node.label}</div>
            <div class="module-id">${formatNodeId(node.id)}</div>
            
            ${moduleSnapshot ? `
                <div class="module-stats">
                    <div class="module-stat">
                        <div class="stat-label">RX</div>
                        <div class="stat-value">${moduleSnapshot.runtime.counters.rx.toLocaleString()}</div>
                    </div>
                    <div class="module-stat">
                        <div class="stat-label">TX</div>
                        <div class="stat-value">${moduleSnapshot.runtime.counters.tx.toLocaleString()}</div>
                    </div>
                    <div class="module-stat">
                        <div class="stat-label">Errors</div>
                        <div class="stat-value">${moduleSnapshot.runtime.counters.errors}</div>
                    </div>
                    <div class="module-stat">
                        <div class="stat-label">Aktiv</div>
                        <div class="stat-value">${formatDuration(Date.now() - moduleSnapshot.runtime.last_activity_ms)}</div>
                    </div>
                </div>
            ` : ''}
        </div>
    `;
}

function renderConsumerGroup(node, outputs, modulesById) {
    if (node.kind === 'processing' && outputs.length > 0) {
        return `
            <div class="consumer-group">
                ${renderPipelineNode(node, modulesById)}
                <div class="consumer-children">
                    ${outputs.map(output => renderPipelineNode(output, modulesById)).join('')}
                </div>
            </div>
        `;
    }

    return renderPipelineNode(node, modulesById);
}

// Render Tables and other components
function renderModulesTable(status) {
    const table = document.getElementById('modulesTable');
    const countElement = document.getElementById('activeModulesCount');
    
    const modules = status.modules || [];
    countElement.textContent = modules.length;
    
    if (modules.length === 0) {
        table.innerHTML = `
            <tbody>
                <tr>
                    <td colspan="4" class="empty-state">
                        <div class="icon">üì¶</div>
                        <div class="message">Keine aktiven Module</div>
                    </td>
                </tr>
            </tbody>`;
        return;
    }
    
    let tableHTML = '<tbody>';
    
    modules.forEach(module => {
        const rate = calculateRate(module.id, module.runtime.counters, status.timestamp_ms);
        const statusInfo = getModuleStatus(module.runtime);
        
        tableHTML += `
            <tr>
                <td>
                    <div style="font-weight: 600;">${module.label}</div>
                    <div style="font-family: monospace; font-size: 10px; color: #888;">${module.id}</div>
                </td>
                <td>
                    <span style="display: inline-block; padding: 2px 6px; border-radius: 4px; font-size: 10px; background: var(--${module.module_type}); color: white;">
                        ${module.module_type}
                    </span>
                </td>
                <td>
                    <div style="display: flex; align-items: center; gap: 6px;">
                        <span class="status-dot ${statusInfo.class}"></span>
                        <span>${statusInfo.text}</span>
                    </div>
                </td>
                <td>
                    <div style="font-family: monospace; font-size: 11px;">
                        <div>RX: ${rate.rx}/min</div>
                        <div>TX: ${rate.tx}/min</div>
                    </div>
                </td>
            </tr>
        `;
    });
    
    tableHTML += '</tbody>';
    table.innerHTML = tableHTML;
}

function renderInactiveModules(status) {
    const table = document.getElementById('inactiveModulesTable');
    const countElement = document.getElementById('inactiveModulesCount');
    
    const inactive = status.inactive_modules || [];
    countElement.textContent = inactive.length;
    
    if (inactive.length === 0) {
        table.innerHTML = `
            <tbody>
                <tr>
                    <td colspan="4" class="empty-state">
                        <div class="icon">üîå</div>
                        <div class="message">Keine inaktiven Module</div>
                    </td>
                </tr>
            </tbody>`;
        return;
    }
    
    let tableHTML = '<tbody>';
    
    inactive.forEach(module => {
        tableHTML += `
            <tr>
                <td>
                    <div style="font-weight: 600;">${module.label}</div>
                    <div style="font-family: monospace; font-size: 10px; color: #888;">${module.id}</div>
                </td>
                <td>
                    <span style="display: inline-block; padding: 2px 6px; border-radius: 4px; font-size: 10px; background: var(--${module.module_type}); color: white;">
                        ${module.module_type}
                    </span>
                </td>
                <td>
                    <div style="display: flex; align-items: center; gap: 6px;">
                        <span class="status-dot inactive"></span>
                        <span>Inaktiv</span>
                    </div>
                </td>
                <td>
                    <span style="font-size: 11px; color: #888;">${module.reason}</span>
                </td>
            </tr>
        `;
    });
    
    tableHTML += '</tbody>';
    table.innerHTML = tableHTML;
}

function renderControls(status) {
    const container = document.getElementById('controlsGrid');
    
    const allControls = [];
    if (status.modules) {
        status.modules.forEach(module => {
            if (module.controls) {
                module.controls.forEach(control => {
                    if (!allControls.some(c => c.action === control.action)) {
                        allControls.push(control);
                    }
                });
            }
        });
    }
    
    if (allControls.length === 0) {
        container.innerHTML = '<button class="btn" disabled>Keine Steuerung</button>';
        return;
    }
    
    container.innerHTML = allControls.map(control => `
        <button class="btn ${control.enabled ? 'primary' : ''}"
                onclick="sendControl('${control.action}')"
                ${!control.enabled ? 'disabled' : ''}
                title="${control.reason || ''}">
            ${control.label}
        </button>
    `).join('');
}

function renderCodecs(codecs) {
    const container = document.getElementById('codecsList');
    
    if (!codecs || codecs.length === 0) {
        container.innerHTML = '<div class="empty-state">Keine Codecs verf√ºgbar</div>';
        return;
    }
    
    container.innerHTML = codecs.map(codec => {
        const status = codec.runtime_state;
        const statusClass = status.enabled ? (status.running ? 'active' : 'standby') : 'inactive';
        const bitrate = codec.config.bitrate ? `${codec.config.bitrate}bps` : 'Variable';
        
        return `
            <div class="codec-item">
                <div class="codec-status">
                    <span class="status-dot ${statusClass}"></span>
                </div>
                <div class="codec-info">
                    <div class="codec-name">${codec.id}</div>
                    <div class="codec-details">${codec.codec_type} @ ${codec.config.sample_rate}Hz</div>
                </div>
                <div style="font-size: 11px; color: #888;">
                    ${codec.metrics.frames} Frames
                </div>
            </div>
        `;
    }).join('');
}

// Update System Status
function updateSystemStatus() {
    const peaksBufferElement = document.getElementById('systemPeaksBuffer');
    const audioBufferElement = document.getElementById('systemAudioBuffer');
    
    if (peaksMeta && peaksMeta.ok) {
        const durationMs = Math.max(0, peaksMeta.end - peaksMeta.start);
        peaksBufferElement.textContent = Math.round(durationMs / ringbufferConfig.chunkMs).toLocaleString();
    } else {
        peaksBufferElement.textContent = '‚Äì';
    }

    if (currentStatus?.ring?.capacity) {
        const durationMs = currentStatus.ring.capacity * ringbufferConfig.chunkMs;
        audioBufferElement.textContent = `${Math.round(durationMs / 1000)}s`;
    } else {
        audioBufferElement.textContent = '‚Äì';
    }
}

async function fetchWaveformHistory(status) {
    try {
        const metaResponse = await fetch('/api/peaks');
        const meta = await metaResponse.json();
        peaksMeta = meta;

        const capacity = status?.ring?.capacity || 6000;
        const chunkMs = ringbufferConfig.chunkMs;
        const bufferDurationMs = capacity * chunkMs;
        
        // Hole Daten f√ºr 20min (2 Buffer-Durchl√§ufe)
        const historyDurationMs = bufferDurationMs * 2;
        const baseTime = meta && meta.ok ? meta.end : (latestStudioTime || Date.now());
        
        ringbufferEndTime = baseTime;
        recorderEndTime = baseTime;

        // Hole 20min History
        const fromTime = Math.max(0, baseTime - historyDurationMs);
        const toTime = baseTime;
        
        const response = await fetch(`/api/history?from=${fromTime}&to=${toTime}`);
        if (response.ok) {
            const data = await response.json();
            ringbufferHistory = Array.isArray(data)
                ? data.map(normalizeHistoryPoint).filter(Boolean)
                : [];
        } else {
            ringbufferHistory = [];
        }

        // Recorder History (nur aktuelle Stunde)
        const now = baseTime;
        const currentHour = Math.floor(now / 1000 / 3600);
        const hourStart = currentHour * 3600 * 1000;
        const hourEnd = hourStart + 3600 * 1000;
        
        const recorderResponse = await fetch(`/api/history?from=${hourStart}&to=${Math.min(now, hourEnd)}`);
        if (recorderResponse.ok) {
            const data = await recorderResponse.json();
            recorderHistory = Array.isArray(data)
                ? data.map(normalizeHistoryPoint).filter(Boolean)
                : [];
        } else {
            recorderHistory = [];
        }

        updateSystemStatus();
    } catch (error) {
        console.warn('Peaks history fetch failed:', error);
        ringbufferHistory = [];
        recorderHistory = [];
    }
}

// Update UI
function updateUI(status) {
    currentStatus = status;
    
    // Update timestamp
    const updateTime = document.getElementById('updateTime');
    updateTime.textContent = formatTime(status.timestamp_ms);
    
    // Render all components
    renderAudioPipeline(status);
    renderModulesTable(status);
    renderInactiveModules(status);
    renderControls(status);
    renderCodecs([]);
    
    // Prepare visualizations
    initCanvases();
    
    // Update system status
    updateSystemStatus();
    
    updateConnectionState(true);
}

// Fetch all data
async function fetchAllData() {
    try {
        const [statusResponse, codecsResponse] = await Promise.all([
            fetch('/api/status'),
            fetch('/api/codecs')
        ]);
        const status = await statusResponse.json();
        const codecs = await codecsResponse.json();
        
        updateUI(status);
        renderCodecs(codecs);
        await fetchWaveformHistory(status);
        
        showMessage('Daten aktualisiert', 'success');
        
    } catch (error) {
        console.error('Data fetch error:', error);
        updateConnectionState(false);
        showMessage('Verbindung fehlgeschlagen', 'error');
    }
}

// Control actions
async function sendControl(action) {
    try {
        const response = await fetch('/api/control', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ action })
        });
        
        const data = await response.json();
        
        if (response.ok) {
            showMessage(data.message || 'Aktion erfolgreich', 'success');
        } else {
            showMessage(data.message || 'Fehler', 'error');
        }
        
        setTimeout(fetchAllData, 500);
        
    } catch (error) {
        showMessage(`Netzwerkfehler: ${error.message}`, 'error');
    }
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
    // Initial fetch
    fetchAllData();
    
    // Initialize canvases
    initCanvases();
    
    // Setup WebSocket
    setupWebSocket();
    
    // Start animation loop
    drawLoop();
});
</script>
</body>
</html>
