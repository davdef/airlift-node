<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Airlift Audio Node</title>
    <style>
        :root {
            --bg: #0a0e14;
            --panel: #141922;
            --panel-light: #1c212c;
            --text: #e3e9f7;
            --muted: #7c85a0;
            --good: #2ecc71;
            --warn: #f1c40f;
            --bad: #e74c3c;
            --accent: #3498db;
            --input: #3498db;
            --buffer: #9b59b6;
            --codec: #e67e22;
            --output: #27ae60;
            --waveform: #1abc9c;
            --peak-left: #3498db;
            --peak-right: #9b59b6;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            background: var(--bg);
            color: var(--text);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            font-size: 13px;
            line-height: 1.5;
        }

        header {
            padding: 16px 24px;
            background: var(--panel);
            border-bottom: 1px solid #252d3d;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .header-left h1 {
            margin: 0 0 4px 0;
            font-size: 18px;
            font-weight: 600;
        }

        .header-subtitle {
            font-size: 12px;
            color: var(--muted);
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .conn-status {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .conn-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--muted);
        }

        .conn-dot.connected { background: var(--good); animation: pulse 2s infinite; }
        .conn-dot.error { background: var(--bad); }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .header-right {
            text-align: right;
        }

        .update-time {
            font-size: 12px;
            color: var(--muted);
        }

        .audio-badge {
            background: rgba(52, 152, 219, 0.1);
            color: var(--accent);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            border: 1px solid rgba(52, 152, 219, 0.3);
        }

        main {
            padding: 24px;
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 24px;
            min-height: calc(100vh - 70px);
        }

        @media (max-width: 1200px) {
            main {
                grid-template-columns: 1fr;
            }
        }

        /* Left Column - Audio Visualization */
        .audio-visualization {
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        /* Ringbuffer Visualization */
        .ringbuffer-visualization {
            background: var(--panel);
            border: 1px solid #252d3d;
            border-radius: 8px;
            overflow: hidden;
            height: 300px;
        }

        .ringbuffer-header {
            padding: 16px 20px;
            border-bottom: 1px solid #252d3d;
            background: var(--panel-light);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .ringbuffer-title {
            margin: 0;
            font-size: 14px;
            font-weight: 600;
        }

        .ringbuffer-subtitle {
            font-size: 12px;
            color: var(--muted);
        }

        .ringbuffer-container {
            padding: 20px;
            height: calc(100% - 57px);
            position: relative;
        }

        .ringbuffer-canvas {
            width: 100%;
            height: 100%;
            background: #0d1220;
            border-radius: 6px;
            border: 1px solid rgba(37, 45, 61, 0.5);
        }

        .ringbuffer-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            bottom: 20px;
            pointer-events: none;
        }

        .ringbuffer-time {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            color: var(--text);
            font-family: 'JetBrains Mono', monospace;
        }

        .ringbuffer-marker {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            z-index: 2;
        }

        .ringbuffer-marker.head {
            background: #ffffff;
            box-shadow: 0 0 10px #ffffff;
        }

        .ringbuffer-marker.tail {
            background: var(--warn);
            box-shadow: 0 0 10px var(--warn);
        }

        .ringbuffer-marker.now {
            background: var(--good);
            box-shadow: 0 0 10px var(--good);
        }

        .ringbuffer-label {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: var(--muted);
            white-space: nowrap;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 6px;
            border-radius: 3px;
        }

        /* Peaks History */
        .peaks-history {
            background: var(--panel);
            border: 1px solid #252d3d;
            border-radius: 8px;
            overflow: hidden;
            height: 200px;
        }

        .peaks-header {
            padding: 12px 20px;
            border-bottom: 1px solid #252d3d;
            background: var(--panel-light);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .peaks-title {
            margin: 0;
            font-size: 14px;
            font-weight: 600;
        }

        .peaks-time-range {
            font-size: 11px;
            color: var(--muted);
            font-family: 'JetBrains Mono', monospace;
        }

        .peaks-container {
            height: calc(100% - 49px);
            padding: 15px;
        }

        .peaks-canvas {
            width: 100%;
            height: 100%;
            background: #0d1220;
            border-radius: 4px;
            border: 1px solid rgba(37, 45, 61, 0.5);
        }

        /* Right Column - Status Panels */
        .status-panels {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .panel {
            background: var(--panel);
            border: 1px solid #252d3d;
            border-radius: 8px;
            overflow: hidden;
        }

        .panel-header {
            padding: 12px 16px;
            border-bottom: 1px solid #252d3d;
            background: var(--panel-light);
        }

        .panel-title {
            margin: 0;
            font-size: 13px;
            font-weight: 600;
        }

        .panel-content {
            padding: 16px;
        }

        /* Audio Pipeline */
        .audio-pipeline {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .pipeline-stage {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .stage-label {
            font-size: 11px;
            color: var(--muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding-left: 12px;
            position: relative;
        }

        .stage-label::before {
            content: '';
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent);
        }

        .stage-modules {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding-left: 12px;
        }

        .module-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            background: var(--panel-light);
            border-radius: 6px;
            border: 1px solid #252d3d;
            transition: all 0.2s ease;
        }

        .module-item:hover {
            border-color: var(--accent);
            transform: translateX(2px);
        }

        .module-status {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .status-dot.active { background: var(--good); }
        .status-dot.ready { background: var(--warn); }
        .status-dot.inactive { background: var(--bad); }
        .status-dot.standby { background: var(--muted); }

        .module-info {
            flex: 1;
        }

        .module-name {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 2px;
        }

        .module-id {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: var(--muted);
        }

        .module-stats {
            font-size: 11px;
            color: var(--muted);
            text-align: right;
            min-width: 80px;
        }

        .module-rate {
            font-family: 'JetBrains Mono', monospace;
        }

        /* Ringbuffer Stats */
        .ringbuffer-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .stat-card {
            background: var(--panel-light);
            padding: 12px;
            border-radius: 6px;
            border-left: 3px solid var(--buffer);
        }

        .stat-label {
            font-size: 11px;
            color: var(--muted);
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .stat-value {
            font-weight: 600;
            font-size: 16px;
            font-family: 'JetBrains Mono', monospace;
        }

        .stat-sub {
            font-size: 11px;
            color: var(--muted);
            margin-top: 2px;
        }

        /* Controls */
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 8px;
        }

        .btn {
            border: none;
            background: var(--panel-light);
            color: var(--text);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            border: 1px solid #252d3d;
            transition: all 0.2s ease;
            text-align: center;
        }

        .btn:hover:not(:disabled) {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .btn.primary {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .btn.small {
            padding: 6px 10px;
            font-size: 11px;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Recorder Info */
        .recorder-info {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .recorder-file {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px;
            background: var(--panel-light);
            border-radius: 6px;
            border: 1px solid #252d3d;
        }

        .file-icon {
            width: 32px;
            height: 32px;
            background: rgba(52, 152, 219, 0.1);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--accent);
        }

        .file-info {
            flex: 1;
        }

        .file-name {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 2px;
            word-break: break-all;
        }

        .file-path {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: var(--muted);
        }

        /* Empty States */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
            text-align: center;
            color: var(--muted);
        }

        .empty-state .icon {
            font-size: 32px;
            margin-bottom: 12px;
            opacity: 0.5;
        }

        .empty-state .message {
            font-size: 14px;
        }

        /* Message Bar */
        .message-bar {
            position: fixed;
            bottom: 24px;
            right: 24px;
            background: var(--panel);
            border: 1px solid;
            border-radius: 6px;
            padding: 12px 16px;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.4);
            z-index: 1000;
            max-width: 400px;
            display: none;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .message-bar.show {
            display: block;
        }

        .message-bar.success {
            border-color: var(--good);
            background: rgba(46, 204, 113, 0.1);
        }

        .message-bar.error {
            border-color: var(--bad);
            background: rgba(231, 76, 60, 0.1);
        }

        .message-bar.warning {
            border-color: var(--warn);
            background: rgba(241, 196, 15, 0.1);
        }

        /* Canvas Legend */
        .canvas-legend {
            display: flex;
            gap: 16px;
            margin-top: 8px;
            font-size: 11px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-color {
            width: 12px;
            height: 4px;
            border-radius: 2px;
        }

        .legend-left { background: var(--peak-left); }
        .legend-right { background: var(--peak-right); }
        .legend-fill { background: var(--waveform); }
    </style>
</head>
<body>
<header>
    <div class="header-left">
        <h1>Airlift Audio Node</h1>
        <div class="header-subtitle">
            <span class="conn-status">
                <span class="conn-dot"></span>
                <span id="connText">Verbinde...</span>
            </span>
            <span>Live Audio Monitoring</span>
        </div>
    </div>
    <div class="header-right">
        <div class="update-time" id="updateTime">‚Äì</div>
        <div style="margin-top: 8px;">
            <span class="audio-badge">SRT ‚Üí WAV Pipeline</span>
        </div>
    </div>
</header>

<main>
    <!-- Left Column - Audio Visualization -->
    <div class="audio-visualization">
        <!-- Ringbuffer Waveform -->
        <section class="ringbuffer-visualization">
            <div class="ringbuffer-header">
                <div>
                    <h3 class="ringbuffer-title">Ringbuffer (60s Audio Buffer)</h3>
                    <div class="ringbuffer-subtitle">Echtzeit-Audio-Waveform</div>
                </div>
                <div class="peaks-time-range" id="ringbufferTime">‚Äì</div>
            </div>
            <div class="ringbuffer-container">
                <canvas class="ringbuffer-canvas" id="ringbufferCanvas"></canvas>
                <div class="ringbuffer-overlay" id="ringbufferOverlay"></div>
            </div>
            <div class="canvas-legend">
                <div class="legend-item">
                    <div class="legend-color legend-left"></div>
                    <span>Left Channel</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color legend-right"></div>
                    <span>Right Channel</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color legend-fill"></div>
                    <span>Buffer Fill</span>
                </div>
            </div>
        </section>

        <!-- Peaks History -->
        <section class="peaks-history">
            <div class="peaks-header">
                <h3 class="peaks-title">Peaks History (100ms Resolution)</h3>
                <div class="peaks-time-range" id="peaksTimeRange">‚Äì</div>
            </div>
            <div class="peaks-container">
                <canvas class="peaks-canvas" id="peaksCanvas"></canvas>
            </div>
        </section>
    </div>

    <!-- Right Column - Status Panels -->
    <div class="status-panels">
        <!-- Audio Pipeline -->
        <section class="panel">
            <div class="panel-header">
                <h3 class="panel-title">Audio Pipeline</h3>
            </div>
            <div class="panel-content">
                <div class="audio-pipeline" id="audioPipeline">
                    <!-- Filled by JavaScript -->
                </div>
            </div>
        </section>

        <!-- Ringbuffer Stats -->
        <section class="panel">
            <div class="panel-header">
                <h3 class="panel-title">Ringbuffer Status</h3>
            </div>
            <div class="panel-content">
                <div class="ringbuffer-stats" id="ringbufferStats">
                    <!-- Filled by JavaScript -->
                </div>
            </div>
        </section>

        <!-- Controls -->
        <section class="panel">
            <div class="panel-header">
                <h3 class="panel-title">Steuerung</h3>
            </div>
            <div class="panel-content">
                <div class="controls-grid" id="controlsGrid">
                    <!-- Filled by JavaScript -->
                </div>
            </div>
        </section>

        <!-- Recorder -->
        <section class="panel">
            <div class="panel-header">
                <h3 class="panel-title">Recorder</h3>
            </div>
            <div class="panel-content">
                <div class="recorder-info" id="recorderInfo">
                    <!-- Filled by JavaScript -->
                </div>
            </div>
        </section>

        <!-- Codecs -->
        <section class="panel">
            <div class="panel-header">
                <h3 class="panel-title">Verf√ºgbare Codecs</h3>
            </div>
            <div class="panel-content">
                <div class="stage-modules" id="codecsList">
                    <!-- Filled by JavaScript -->
                </div>
            </div>
        </section>
    </div>
</main>

<div id="messageBar" class="message-bar"></div>

<script>
// State
let currentStatus = null;
let peaksHistory = [];
let peaksData = null;
const rateHistory = new Map();

// Canvas setup
const ringbufferCanvas = document.getElementById('ringbufferCanvas');
const ringbufferCtx = ringbufferCanvas.getContext('2d');
const peaksCanvas = document.getElementById('peaksCanvas');
const peaksCtx = peaksCanvas.getContext('2d');

// Initialize canvas sizes
function initCanvases() {
    const container = ringbufferCanvas.parentElement;
    ringbufferCanvas.width = container.clientWidth;
    ringbufferCanvas.height = container.clientHeight;
    
    const peaksContainer = peaksCanvas.parentElement;
    peaksCanvas.width = peaksContainer.clientWidth;
    peaksCanvas.height = peaksContainer.clientHeight;
}

window.addEventListener('resize', initCanvases);

// Helper functions
function showMessage(text, type = 'info') {
    const bar = document.getElementById('messageBar');
    bar.textContent = text;
    bar.className = `message-bar show ${type}`;
    
    setTimeout(() => {
        bar.className = 'message-bar';
    }, 3000);
}

function updateConnectionState(connected) {
    const dot = document.querySelector('.conn-dot');
    const text = document.getElementById('connText');
    
    if (connected) {
        dot.className = 'conn-dot connected';
        text.textContent = 'Verbunden';
    } else {
        dot.className = 'conn-dot error';
        text.textContent = 'Getrennt';
    }
}

function formatTime(ms) {
    if (!ms) return '‚Äì';
    const date = new Date(ms);
    return date.toLocaleTimeString('de-DE', {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
    });
}

function formatDuration(ms) {
    const seconds = Math.floor(ms / 1000);
    if (seconds < 60) return `${seconds}s`;
    const minutes = Math.floor(seconds / 60);
    if (minutes < 60) return `${minutes}m`;
    const hours = Math.floor(minutes / 60);
    return `${hours}h`;
}

function formatTimeAgo(ms) {
    if (!ms || ms === 0) return 'nie';
    const diff = Date.now() - ms;
    return formatDuration(diff);
}

function calculateRate(moduleId, currentCounters, timestamp) {
    if (!rateHistory.has(moduleId)) {
        rateHistory.set(moduleId, {
            timestamp,
            counters: currentCounters
        });
        return { rx: '‚Äì', tx: '‚Äì', rxRaw: 0, txRaw: 0 };
    }
    
    const prev = rateHistory.get(moduleId);
    const timeDiff = Math.max(1, timestamp - prev.timestamp);
    
    const rxRate = Math.round((currentCounters.rx - prev.counters.rx) * 60000 / timeDiff);
    const txRate = Math.round((currentCounters.tx - prev.counters.tx) * 60000 / timeDiff);
    
    rateHistory.set(moduleId, {
        timestamp,
        counters: currentCounters
    });
    
    return {
        rx: rxRate.toLocaleString(),
        tx: txRate.toLocaleString(),
        rxRaw: rxRate,
        txRaw: txRate
    };
}

function getModuleStatus(runtime) {
    if (!runtime.enabled) return { class: 'inactive', label: 'Aus', text: 'Deaktiviert' };
    if (!runtime.running) return { class: 'standby', label: 'Bereit', text: 'Bereit' };
    if (runtime.connected === false) return { class: 'ready', label: 'Bereit', text: 'Getrennt' };
    return { class: 'active', label: 'Aktiv', text: 'Aktiv' };
}

// Draw Ringbuffer Waveform
function drawRingbufferWaveform(status) {
    if (!ringbufferCtx || !status.ring) return;
    
    const width = ringbufferCanvas.width;
    const height = ringbufferCanvas.height;
    const ring = status.ring;
    
    // Clear canvas
    ringbufferCtx.fillStyle = '#0d1220';
    ringbufferCtx.fillRect(0, 0, width, height);
    
    // Draw grid
    ringbufferCtx.strokeStyle = 'rgba(124, 133, 160, 0.2)';
    ringbufferCtx.lineWidth = 1;
    
    // Vertical lines (time markers)
    for (let i = 1; i < 6; i++) {
        const x = (width / 6) * i;
        ringbufferCtx.beginPath();
        ringbufferCtx.moveTo(x, 0);
        ringbufferCtx.lineTo(x, height);
        ringbufferCtx.stroke();
    }
    
    // Horizontal lines (amplitude markers)
    for (let i = 1; i < 4; i++) {
        const y = (height / 4) * i;
        ringbufferCtx.beginPath();
        ringbufferCtx.moveTo(0, y);
        ringbufferCtx.lineTo(width, y);
        ringbufferCtx.stroke();
    }
    
    // Draw center line
    ringbufferCtx.strokeStyle = 'rgba(124, 133, 160, 0.4)';
    ringbufferCtx.beginPath();
    ringbufferCtx.moveTo(0, height / 2);
    ringbufferCtx.lineTo(width, height / 2);
    ringbufferCtx.stroke();
    
    // Draw waveform (simulated - in reality would need actual audio data)
    // Since we only have peaks, we'll draw based on the fill ratio and markers
    const fillRatio = ring.fill_ratio || 0;
    
    // Draw fill area
    if (fillRatio > 0) {
        const fillWidth = width * fillRatio;
        ringbufferCtx.fillStyle = 'rgba(26, 188, 156, 0.1)';
        ringbufferCtx.fillRect(0, 0, fillWidth, height);
        
        // Draw fill border
        ringbufferCtx.strokeStyle = 'rgba(26, 188, 156, 0.3)';
        ringbufferCtx.lineWidth = 2;
        ringbufferCtx.beginPath();
        ringbufferCtx.moveTo(fillWidth, 0);
        ringbufferCtx.lineTo(fillWidth, height);
        ringbufferCtx.stroke();
    }
    
    // Draw markers
    const overlay = document.getElementById('ringbufferOverlay');
    overlay.innerHTML = '';
    
    if (ring.capacity > 0) {
        // Head marker (write position)
        const headPos = (ring.head_index / ring.capacity) * width;
        const headMarker = document.createElement('div');
        headMarker.className = 'ringbuffer-marker head';
        headMarker.style.left = `${headPos}px`;
        const headLabel = document.createElement('div');
        headLabel.className = 'ringbuffer-label';
        headLabel.textContent = 'Head';
        headMarker.appendChild(headLabel);
        overlay.appendChild(headMarker);
        
        // Tail marker (oldest readable position)
        const tailPos = (ring.tail_index / ring.capacity) * width;
        const tailMarker = document.createElement('div');
        tailMarker.className = 'ringbuffer-marker tail';
        tailMarker.style.left = `${tailPos}px`;
        const tailLabel = document.createElement('div');
        tailLabel.className = 'ringbuffer-label';
        tailLabel.textContent = 'Tail';
        tailMarker.appendChild(tailLabel);
        overlay.appendChild(tailMarker);
        
        // Current time marker
        const nowPos = width * 0.5; // Center for now
        const nowMarker = document.createElement('div');
        nowMarker.className = 'ringbuffer-marker now';
        nowMarker.style.left = `${nowPos}px`;
        overlay.appendChild(nowMarker);
    }
    
    // Update time display
    const timeElement = document.getElementById('ringbufferTime');
    const now = Date.now();
    timeElement.textContent = `${formatTime(now)} | Fill: ${Math.round(fillRatio * 100)}%`;
}

// Draw Peaks History
function drawPeaksHistory() {
    if (!peaksCtx || !peaksData) return;
    
    const width = peaksCanvas.width;
    const height = peaksCanvas.height;
    
    // Clear canvas
    peaksCtx.fillStyle = '#0d1220';
    peaksCtx.fillRect(0, 0, width, height);
    
    if (peaksData.length === 0) {
        // Draw "No data" message
        peaksCtx.fillStyle = 'rgba(124, 133, 160, 0.5)';
        peaksCtx.font = '14px sans-serif';
        peaksCtx.textAlign = 'center';
        peaksCtx.textBaseline = 'middle';
        peaksCtx.fillText('Keine Peak-Daten verf√ºgbar', width / 2, height / 2);
        return;
    }
    
    // Draw grid
    peaksCtx.strokeStyle = 'rgba(124, 133, 160, 0.2)';
    peaksCtx.lineWidth = 1;
    
    // Vertical lines
    for (let i = 1; i < 10; i++) {
        const x = (width / 10) * i;
        peaksCtx.beginPath();
        peaksCtx.moveTo(x, 0);
        peaksCtx.lineTo(x, height);
        peaksCtx.stroke();
    }
    
    // Draw peaks
    const midY = height / 2;
    const barWidth = width / peaksData.length;
    
    for (let i = 0; i < peaksData.length; i++) {
        const point = peaksData[i];
        const x = i * barWidth;
        
        // Left channel (blue)
        const leftHeight = Math.min(point.peaks[0] * height, height / 2);
        peaksCtx.fillStyle = 'rgba(52, 152, 219, 0.6)';
        peaksCtx.fillRect(x, midY - leftHeight, barWidth - 1, leftHeight);
        
        // Right channel (purple)
        const rightHeight = Math.min(point.peaks[1] * height, height / 2);
        peaksCtx.fillStyle = 'rgba(155, 89, 182, 0.6)';
        peaksCtx.fillRect(x, midY, barWidth - 1, rightHeight);
        
        // Silence indicator (red dot)
        if (point.silence) {
            peaksCtx.fillStyle = 'rgba(231, 76, 60, 0.8)';
            peaksCtx.beginPath();
            peaksCtx.arc(x + barWidth / 2, midY, 2, 0, Math.PI * 2);
            peaksCtx.fill();
        }
    }
    
    // Draw time range
    const timeRange = document.getElementById('peaksTimeRange');
    if (peaksData.length > 0) {
        const first = peaksData[0];
        const last = peaksData[peaksData.length - 1];
        const duration = last.timestamp - first.timestamp;
        timeRange.textContent = `${formatDuration(duration)} @ ${peaksData.length} Punkte`;
    }
}

// Render Audio Pipeline
function renderAudioPipeline(status) {
    const pipeline = document.getElementById('audioPipeline');
    
    if (!status.modules || status.modules.length === 0) {
        pipeline.innerHTML = `
            <div class="empty-state">
                <div class="icon">üîá</div>
                <div class="message">Keine aktiven Module</div>
            </div>`;
        return;
    }
    
    // Sort modules by type
    const inputs = status.modules.filter(m => m.module_type === 'input');
    const buffers = status.modules.filter(m => m.module_type === 'buffer');
    const outputs = status.modules.filter(m => m.module_type === 'output');
    
    let pipelineHTML = '';
    
    // Input stage
    if (inputs.length > 0) {
        pipelineHTML += `
            <div class="pipeline-stage">
                <div class="stage-label">Input</div>
                <div class="stage-modules">
                    ${inputs.map(module => renderPipelineModule(module, status)).join('')}
                </div>
            </div>
            <div style="text-align: center; color: var(--accent); margin: 8px 0;">‚Üì</div>`;
    }
    
    // Buffer stage
    if (buffers.length > 0) {
        pipelineHTML += `
            <div class="pipeline-stage">
                <div class="stage-label">Ringbuffer</div>
                <div class="stage-modules">
                    ${buffers.map(module => renderPipelineModule(module, status)).join('')}
                </div>
            </div>
            <div style="text-align: center; color: var(--accent); margin: 8px 0;">‚Üì</div>`;
    }
    
    // Output stage
    if (outputs.length > 0) {
        pipelineHTML += `
            <div class="pipeline-stage">
                <div class="stage-label">Output</div>
                <div class="stage-modules">
                    ${outputs.map(module => renderPipelineModule(module, status)).join('')}
                </div>
            </div>`;
    }
    
    pipeline.innerHTML = pipelineHTML;
}

function renderPipelineModule(module, status) {
    const statusInfo = getModuleStatus(module.runtime);
    const rate = calculateRate(module.id, module.runtime.counters, status.timestamp_ms);
    
    return `
        <div class="module-item">
            <div class="module-status">
                <span class="status-dot ${statusInfo.class}"></span>
            </div>
            <div class="module-info">
                <div class="module-name">${module.label}</div>
                <div class="module-id">${module.id}</div>
            </div>
            <div class="module-stats">
                <div class="module-rate">RX: ${rate.rx}/min</div>
                <div class="module-rate">TX: ${rate.tx}/min</div>
            </div>
        </div>
    `;
}

// Render Ringbuffer Stats
function renderRingbufferStats(status) {
    const container = document.getElementById('ringbufferStats');
    const ring = status.ring;
    
    if (!ring) {
        container.innerHTML = '<div class="empty-state">Keine Ringbuffer-Daten</div>';
        return;
    }
    
    const fillPercent = Math.round((ring.fill_ratio || 0) * 100);
    const capacity = ring.capacity || 0;
    const fill = ring.fill || 0;
    
    container.innerHTML = `
        <div class="stat-card">
            <div class="stat-label">F√ºllstand</div>
            <div class="stat-value">${fillPercent}%</div>
            <div class="stat-sub">${fill} / ${capacity} Slots</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Head Seq</div>
            <div class="stat-value">${ring.head_seq || 0}</div>
            <div class="stat-sub">Schreibposition</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Next Seq</div>
            <div class="stat-value">${ring.next_seq || 0}</div>
            <div class="stat-sub">Leseposition</div>
        </div>
        <div class="stat-card">
            <div class="stat-label">Buffer</div>
            <div class="stat-value">${capacity}</div>
            <div class="stat-sub">Kapazit√§t (Slots)</div>
        </div>
    `;
}

// Render Controls
function renderControls(status) {
    const container = document.getElementById('controlsGrid');
    
    // Collect all unique controls from modules
    const allControls = [];
    if (status.modules) {
        status.modules.forEach(module => {
            if (module.controls) {
                module.controls.forEach(control => {
                    if (!allControls.some(c => c.action === control.action)) {
                        allControls.push(control);
                    }
                });
            }
        });
    }
    
    if (allControls.length === 0) {
        container.innerHTML = '<button class="btn" disabled>Keine Steuerung verf√ºgbar</button>';
        return;
    }
    
    container.innerHTML = allControls.map(control => `
        <button class="btn ${control.enabled ? 'primary' : ''}"
                onclick="sendControl('${control.action}')"
                ${!control.enabled ? 'disabled' : ''}
                title="${control.reason || ''}">
            ${control.label}
        </button>
    `).join('');
}

// Render Recorder Info
function renderRecorderInfo(status) {
    const container = document.getElementById('recorderInfo');
    const recorder = status.recorder;
    
    if (!recorder || !recorder.enabled) {
        container.innerHTML = '<div class="empty-state">Recorder nicht aktiv</div>';
        return;
    }
    
    let filesHTML = '';
    if (recorder.current_files && recorder.current_files.length > 0) {
        filesHTML = recorder.current_files.map(file => `
            <div class="recorder-file">
                <div class="file-icon">üìÅ</div>
                <div class="file-info">
                    <div class="file-name">${file.split('/').pop()}</div>
                    <div class="file-path">${file}</div>
                </div>
            </div>
        `).join('');
    }
    
    container.innerHTML = `
        <div style="margin-bottom: 12px;">
            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                <span style="color: var(--muted);">Format:</span>
                <span style="font-weight: 600;">${recorder.format || '‚Äì'}</span>
            </div>
            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                <span style="color: var(--muted);">Pfad:</span>
                <span style="font-family: 'JetBrains Mono', monospace; font-size: 11px;">${recorder.path}</span>
            </div>
            <div style="display: flex; justify-content: space-between;">
                <span style="color: var(--muted);">Retention:</span>
                <span>${recorder.retention_days || 0} Tage</span>
            </div>
        </div>
        ${filesHTML}
    `;
}

// Render Codecs
function renderCodecs(codecs) {
    const container = document.getElementById('codecsList');
    
    if (!codecs || codecs.length === 0) {
        container.innerHTML = '<div class="empty-state">Keine Codecs verf√ºgbar</div>';
        return;
    }
    
    container.innerHTML = codecs.map(codec => {
        const status = codec.runtime_state;
        const statusClass = status.enabled ? (status.running ? 'active' : 'standby') : 'inactive';
        const statusText = status.enabled ? (status.running ? 'Aktiv' : 'Bereit') : 'Deaktiviert';
        
        return `
            <div class="module-item">
                <div class="module-status">
                    <span class="status-dot ${statusClass}"></span>
                </div>
                <div class="module-info">
                    <div class="module-name">${codec.id}</div>
                    <div class="module-id">${codec.codec_type} @ ${codec.config.sample_rate}Hz</div>
                </div>
                <div class="module-stats">
                    <div>Frames: ${codec.metrics.frames}</div>
                </div>
            </div>
        `;
    }).join('');
}

// Fetch Peaks History
async function fetchPeaksHistory() {
    try {
        // First get the time range
        const metaResponse = await fetch('/api/peaks');
        const meta = await metaResponse.json();
        
        if (!meta.ok || !meta.start || !meta.end) {
            console.log('Keine Peak-Metadaten verf√ºgbar');
            return;
        }
        
        // Get last hour of peaks
        const to = meta.end;
        const from = to - (60 * 60 * 1000); // Last hour
        
        const response = await fetch(`/api/history?from=${from}&to=${to}`);
        const data = await response.json();
        
        peaksData = data;
        drawPeaksHistory();
        
    } catch (error) {
        console.error('Fehler beim Abrufen der Peaks:', error);
        peaksData = [];
        drawPeaksHistory();
    }
}

// Update UI
function updateUI(status) {
    currentStatus = status;
    
    // Update timestamp
    const updateTime = document.getElementById('updateTime');
    updateTime.textContent = formatTime(status.timestamp_ms);
    
    // Draw visualizations
    initCanvases();
    drawRingbufferWaveform(status);
    drawPeaksHistory();
    
    // Render panels
    renderAudioPipeline(status);
    renderRingbufferStats(status);
    renderControls(status);
    renderRecorderInfo(status);
    
    updateConnectionState(true);
}

// Fetch all data
async function fetchAllData() {
    try {
        // Fetch status
        const statusResponse = await fetch('/api/status');
        const status = await statusResponse.json();
        
        // Fetch codecs
        const codecsResponse = await fetch('/api/codecs');
        const codecs = await codecsResponse.json();
        
        // Update UI with status
        updateUI(status);
        
        // Render codecs
        renderCodecs(codecs);
        
        // Fetch peaks history
        await fetchPeaksHistory();
        
    } catch (error) {
        console.error('Fehler beim Abrufen der Daten:', error);
        updateConnectionState(false);
        showMessage('Verbindung zum Server fehlgeschlagen', 'error');
    }
}

// Control actions
async function sendControl(action) {
    try {
        const response = await fetch('/api/control', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ action })
        });
        
        const data = await response.json();
        
        if (response.ok) {
            showMessage(data.message || 'Aktion erfolgreich', 'success');
        } else {
            showMessage(data.message || 'Fehler bei der Aktion', 'error');
        }
        
        // Refresh data
        setTimeout(fetchAllData, 500);
        
    } catch (error) {
        showMessage(`Netzwerkfehler: ${error.message}`, 'error');
    }
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
    // Initial fetch
    fetchAllData();
    
    // Initialize canvases
    initCanvases();
    
    // Polling for updates
    setInterval(fetchAllData, 2000);
    
    // Auto-refresh peaks every 30 seconds
    setInterval(fetchPeaksHistory, 30000);
});
</script>
</body>
</html>
