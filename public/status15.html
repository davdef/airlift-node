<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Airlift Audio Node</title>
    <style>
        :root {
            --bg: #0b0e11;
            --panel: #14171c;
            --panel-light: #1c2128;
            --blue: #5aa0ff;
            --blue-light: #8cc2ff;
            --text: #d8e4f0;
            --good: #2ecc71;
            --warn: #f1c40f;
            --bad: #e74c3c;
            --input: #3498db;
            --buffer: #9b59b6;
            --output: #27ae60;
            --codec: #e67e22;
            --service: #e84393;
            --processing: #f39c12;
            --wave-active: #5aa0ff;
            --wave-ghost: rgba(90, 160, 255, 0.3);
            --wave-bg: rgba(90, 160, 255, 0.1);
            --gap: rgba(231, 76, 60, 0.5);
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            background: var(--bg);
            color: var(--text);
            font-family: system-ui, sans-serif;
            overflow-x: hidden;
        }

        /* HEADER --------------------------------------------------- */
        header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 16px;
            background: var(--panel);
            border-bottom: 1px solid #222;
        }

        header img {
            height: 36px;
            opacity: 0.95;
        }

        header h1 {
            font-size: 22px;
            font-weight: bold;
            color: #ffffff;
            font-weight: 500;
            text-transform: uppercase;
            margin: 0;
        }

        .header-meta {
            margin-left: auto;
            text-align: right;
            font-size: 12px;
        }

        .conn-status {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .conn-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #888;
        }

        .conn-dot.connected { background: var(--good); animation: pulse 2s infinite; }
        .conn-dot.error { background: var(--bad); }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .studio-time {
            font-family: monospace;
            font-size: 13px;
            color: var(--blue-light);
            margin-top: 2px;
        }

        /* MAIN LAYOUT ---------------------------------------------- */
        main {
            padding: 16px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            max-width: 1600px;
            margin: 0 auto;
        }

        @media (max-width: 1200px) {
            main {
                grid-template-columns: 1fr;
            }
        }

        /* PANELS --------------------------------------------------- */
        .panel {
            background: var(--panel);
            border: 1px solid #222;
            border-radius: 8px;
            overflow: hidden;
        }

        .panel-header {
            padding: 12px 16px;
            background: var(--panel-light);
            border-bottom: 1px solid #222;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .panel-title {
            margin: 0;
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--blue-light);
        }

        .panel-content {
            padding: 16px;
        }

        /* AUDIO PIPELINE TREE -------------------------------------- */
        .pipeline-tree {
            grid-column: 1 / -1;
            min-height: 200px;
        }

        .tree-container {
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .tree-level {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            position: relative;
        }

        .tree-level:not(:last-child)::after {
            content: '';
            position: absolute;
            left: 50%;
            bottom: -15px;
            transform: translateX(-50%);
            width: 2px;
            height: 15px;
            background: linear-gradient(to bottom, var(--blue), transparent);
        }

        .level-label {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
            align-self: flex-start;
            padding-left: 16px;
            position: relative;
        }

        .level-label::before {
            content: '';
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 10px;
            height: 2px;
            background: var(--blue);
        }

        .level-modules {
            display: flex;
            justify-content: center;
            gap: 15px;
            width: 100%;
        }

        /* MODULE CARDS -------------------------------------------- */
        .module-card {
            background: var(--panel-light);
            border: 2px solid;
            border-radius: 6px;
            padding: 14px;
            min-width: 180px;
            text-align: center;
            position: relative;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .module-card.input { border-color: var(--input); }
        .module-card.buffer { border-color: var(--buffer); }
        .module-card.output { border-color: var(--output); }
        .module-card.service { border-color: var(--service); }
        .module-card.processing { border-color: var(--processing); }

        .module-header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 10px;
        }

        .module-type {
            font-size: 10px;
            padding: 3px 8px;
            border-radius: 10px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .type-input { background: var(--input); color: white; }
        .type-buffer { background: var(--buffer); color: white; }
        .type-output { background: var(--output); color: white; }
        .type-service { background: var(--service); color: white; }
        .type-processing { background: var(--processing); color: white; }

        .module-status {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 11px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .status-dot.active { background: var(--good); }
        .status-dot.ready { background: var(--warn); }
        .status-dot.inactive { background: var(--bad); }
        .status-dot.standby { background: #888; }

        .module-title {
            font-weight: 600;
            font-size: 15px;
            margin-bottom: 4px;
        }

        .module-id {
            font-family: monospace;
            font-size: 10px;
            color: #888;
            margin-bottom: 10px;
        }

        .module-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #222;
            font-size: 11px;
        }

        .module-stat {
            display: flex;
            flex-direction: column;
        }

        .consumer-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            min-width: 200px;
        }

        .consumer-children {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .stat-label {
            font-size: 9px;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 2px;
        }

        .stat-value {
            font-weight: 600;
            font-family: monospace;
            font-size: 12px;
        }

        /* WAVEFORM VISUALIZATIONS -------------------------------- */
        .waveform-container {
            height: 140px;
            background: #0d1117;
            border-radius: 6px;
            border: 1px solid #222;
            position: relative;
            overflow: hidden;
            margin-bottom: 12px;
        }

        .waveform-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .waveform-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        .waveform-marker {
            position: absolute;
            top: -6px;
            bottom: -6px;
            width: 3px;
            transform: translateX(-50%);
            border-radius: 2px;
            z-index: 10;
        }

        .waveform-marker.head {
            background: #ffffff;
            box-shadow: 0 0 10px #ffffff;
        }

        .waveform-marker.tail {
            background: var(--warn);
            box-shadow: 0 0 10px var(--warn);
        }

        .waveform-time-display {
            position: absolute;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 4px 12px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            color: var(--text);
        }

        .waveform-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 8px;
            font-size: 11px;
        }

        .waveform-stat {
            background: var(--panel-light);
            padding: 8px;
            border-radius: 4px;
            border-left: 3px solid var(--blue);
        }

        .waveform-stat-label {
            color: #888;
            text-transform: uppercase;
            margin-bottom: 4px;
            font-size: 10px;
        }

        .waveform-stat-value {
            font-weight: 600;
            font-family: monospace;
            font-size: 14px;
        }

        .waveform-stat-sub {
            font-size: 10px;
            color: #888;
            margin-top: 2px;
        }

        /* TABLES -------------------------------------------------- */
        .compact-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .compact-table th {
            text-align: left;
            padding: 8px 12px;
            color: #888;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 10px;
            letter-spacing: 0.5px;
            border-bottom: 1px solid #222;
        }

        .compact-table td {
            padding: 8px 12px;
            border-bottom: 1px solid rgba(34, 34, 34, 0.5);
        }

        .compact-table tr:hover {
            background: rgba(255, 255, 255, 0.02);
        }

        /* CONTROLS ------------------------------------------------ */
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 8px;
        }

        button {
            padding: 8px 12px;
            font-size: 12px;
            border-radius: 6px;
            border: none;
            color: var(--bg);
            background: var(--blue);
            cursor: pointer;
            font-weight: 500;
            border: 1px solid var(--blue);
            transition: all 0.2s ease;
            text-align: center;
        }

        button:hover:not(:disabled) {
            background: var(--blue-light);
            border-color: var(--blue-light);
        }

        button.primary {
            background: var(--blue);
            color: var(--bg);
        }

        button.small {
            padding: 6px 10px;
            font-size: 11px;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* RECORDER INFO ------------------------------------------- */
        .recorder-files {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .file-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: var(--panel-light);
            border-radius: 4px;
            border: 1px solid #222;
        }

        .file-icon {
            width: 24px;
            height: 24px;
            background: rgba(90, 160, 255, 0.1);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--blue);
        }

        .file-info {
            flex: 1;
        }

        .file-name {
            font-weight: 600;
            font-size: 12px;
            margin-bottom: 2px;
        }

        .file-path {
            font-family: monospace;
            font-size: 10px;
            color: #888;
        }

        .file-size {
            font-size: 10px;
            color: var(--blue-light);
        }

        /* CODECS LIST --------------------------------------------- */
        .codecs-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .codec-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: var(--panel-light);
            border-radius: 4px;
            border: 1px solid #222;
        }

        .codec-status {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .codec-info {
            flex: 1;
        }

        .codec-name {
            font-weight: 600;
            font-size: 12px;
            margin-bottom: 2px;
        }

        .codec-details {
            font-family: monospace;
            font-size: 10px;
            color: #888;
        }

        /* EMPTY STATES -------------------------------------------- */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 30px 20px;
            text-align: center;
            color: #888;
        }

        .empty-state .icon {
            font-size: 24px;
            margin-bottom: 8px;
            opacity: 0.5;
        }

        .empty-state .message {
            font-size: 13px;
        }

        /* RESPONSIVE ---------------------------------------------- */
        @media (max-width: 768px) {
            main {
                padding: 12px;
                gap: 12px;
            }
            
            .level-modules {
                flex-direction: column;
                align-items: center;
            }
            
            .module-card {
                width: 100%;
                max-width: 250px;
            }
            
            .waveform-container {
                height: 100px;
            }
            
            .compact-table {
                font-size: 11px;
            }
            
            .compact-table th,
            .compact-table td {
                padding: 6px 8px;
            }
        }
    </style>
</head>
<body>
<header>
    <img src="rfm-logo.png" alt="RFM Logo">
    <h1>Airlift Audio Node</h1>
    <div class="header-meta">
        <div class="conn-status">
            <span class="conn-dot"></span>
            <span id="connText">Verbinde...</span>
        </div>
        <div class="studio-time" id="studioTime">‚Äì</div>
        <div style="font-size: 12px; color: #888;">
            Aktualisiert: <span id="updateTime">‚Äì</span>
        </div>
    </div>
</header>

<main>
    <!-- Audio Pipeline Tree -->
    <section class="panel pipeline-tree">
        <div class="panel-header">
            <h2 class="panel-title">Audio Pipeline</h2>
            <button class="btn small" onclick="refreshAllData()">‚Üª Aktualisieren</button>
        </div>
        <div class="tree-container" id="pipelineTree">
            <div class="empty-state">
                <div class="icon">üéµ</div>
                <div class="message">Lade Audio-Pipeline...</div>
            </div>
        </div>
    </section>

    <!-- Ringbuffer Visualization -->
    <section class="panel">
        <div class="panel-header">
            <h2 class="panel-title" id="ringbufferTitle">Ringbuffer</h2>
            <div style="font-size: 11px; color: #888;">
                <span id="ringbufferInfo">F√ºllstand: 0%</span>
            </div>
        </div>
        <div class="panel-content">
            <div class="waveform-container">
                <canvas class="waveform-canvas" id="ringbufferCanvas"></canvas>
                <div class="waveform-overlay" id="ringbufferOverlay"></div>
                <div class="waveform-time-display" id="ringbufferTime">‚Äì</div>
            </div>
            <div class="waveform-stats" id="ringbufferStats">
                <!-- Stats will be added here -->
            </div>
        </div>
    </section>

    <!-- Recorder WAV File -->
    <section class="panel">
        <div class="panel-header">
            <h2 class="panel-title">Recorder (1h WAV Datei)</h2>
            <div style="font-size: 11px; color: #888;">
                <span id="recorderProgress">0%</span>
            </div>
        </div>
        <div class="panel-content">
            <div class="waveform-container">
                <canvas class="waveform-canvas" id="recorderCanvas"></canvas>
                <div class="waveform-overlay" id="recorderOverlay"></div>
                <div class="waveform-time-display" id="recorderTime">‚Äì</div>
            </div>
            <div class="recorder-files" id="recorderFiles">
                <div class="empty-state">
                    <div class="icon">üìÅ</div>
                    <div class="message">Lade Recorder-Info...</div>
                </div>
            </div>
        </div>
    </section>

    <!-- Left Column -->
    <div style="display: flex; flex-direction: column; gap: 16px;">
        <!-- Active Modules -->
        <section class="panel">
            <div class="panel-header">
                <h2 class="panel-title">Aktive Module</h2>
                <span style="font-size: 11px; color: #888;" id="activeModulesCount">0</span>
            </div>
            <div class="panel-content">
                <table class="compact-table" id="modulesTable">
                    <thead>
                        <tr>
                            <th>Modul</th>
                            <th>Typ</th>
                            <th>Status</th>
                            <th>Datenrate</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td colspan="4" class="empty-state">
                                <div class="icon">üì¶</div>
                                <div class="message">Lade Module...</div>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <!-- Available Modules -->
        <section class="panel">
            <div class="panel-header">
                <h2 class="panel-title">Verf√ºgbare Module</h2>
                <span style="font-size: 11px; color: #888;" id="inactiveModulesCount">0</span>
            </div>
            <div class="panel-content">
                <table class="compact-table" id="inactiveModulesTable">
                    <thead>
                        <tr>
                            <th>Modul</th>
                            <th>Typ</th>
                            <th>Status</th>
                            <th>Grund</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td colspan="4" class="empty-state">
                                <div class="icon">üîå</div>
                                <div class="message">Keine inaktiven Module</div>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>
    </div>

    <!-- Right Column -->
    <div style="display: flex; flex-direction: column; gap: 16px;">
        <!-- Controls -->
        <section class="panel">
            <div class="panel-header">
                <h2 class="panel-title">Steuerung</h2>
            </div>
            <div class="panel-content">
                <div class="controls-grid" id="controlsGrid">
                    <button class="btn" disabled>Lade...</button>
                </div>
            </div>
        </section>

        <!-- Codecs -->
        <section class="panel">
            <div class="panel-header">
                <h2 class="panel-title">Verf√ºgbare Codecs</h2>
            </div>
            <div class="panel-content">
                <div class="codecs-list" id="codecsList">
                    <div class="empty-state">
                        <div class="icon">üîä</div>
                        <div class="message">Lade Codecs...</div>
                    </div>
                </div>
            </div>
        </section>

        <!-- System Status -->
        <section class="panel">
            <div class="panel-header">
                <h2 class="panel-title">System Status</h2>
            </div>
            <div class="panel-content">
                <div class="waveform-stats">
                    <div class="waveform-stat">
                        <div class="waveform-stat-label">Studio-Zeit</div>
                        <div class="waveform-stat-value" id="systemStudioTime">‚Äì</div>
                        <div class="waveform-stat-sub">Sendezeit aus Studio</div>
                    </div>
                    <div class="waveform-stat">
                        <div class="waveform-stat-label">Latenz</div>
                        <div class="waveform-stat-value" id="systemLatency">‚Äì</div>
                        <div class="waveform-stat-sub">Verz√∂gerung</div>
                    </div>
                    <div class="waveform-stat">
                        <div class="waveform-stat-label">Peaks Buffer</div>
                        <div class="waveform-stat-value" id="systemPeaksBuffer">‚Äì</div>
                        <div class="waveform-stat-sub">100ms Punkte</div>
                    </div>
                    <div class="waveform-stat">
                        <div class="waveform-stat-label">Audio Buffer</div>
                        <div class="waveform-stat-value" id="systemAudioBuffer">‚Äì</div>
                        <div class="waveform-stat-sub">Sekunden</div>
                    </div>
                </div>
            </div>
        </section>
    </div>
</main>

<script>
// State
let currentStatus = null;
let latestStudioTime = null;
let websocket = null;
const rateHistory = new Map();
let wsMessageCount = 0;
let autoRefreshInterval = null;

// Ringbuffer State
let ringbufferData = null;
let bufferCapacity = 6000;
let bufferHeadIndex = 0;
let bufferTailIndex = 0;
let lastPeakTime = 0;

// Recorder State
let recorderData = [];

// Canvas setup
const ringbufferCanvas = document.getElementById('ringbufferCanvas');
const ringbufferCtx = ringbufferCanvas.getContext('2d');
const recorderCanvas = document.getElementById('recorderCanvas');
const recorderCtx = recorderCanvas.getContext('2d');

// Initialize canvases
function initCanvases() {
    const ringbufferContainer = ringbufferCanvas.parentElement;
    ringbufferCanvas.width = ringbufferContainer.clientWidth;
    ringbufferCanvas.height = ringbufferContainer.clientHeight;
    
    const recorderContainer = recorderCanvas.parentElement;
    recorderCanvas.width = recorderContainer.clientWidth;
    recorderCanvas.height = recorderContainer.clientHeight;
}

window.addEventListener('resize', initCanvases);

// Helper functions
function formatTime(ms) {
    if (!ms) return '‚Äì';
    const date = new Date(ms);
    return date.toLocaleTimeString('de-DE', {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
    });
}

function normalizeHistoryPoint(point) {
    if (!point) return null;
    const ts = point.ts || point.timestamp;
    if (!ts) return null;
    return {
        ts,
        peaks: point.peaks || [point.peak_l || 0, point.peak_r || 0],
        silence: Boolean(point.silence)
    };
}

// Ringbuffer initialization - KORREKTE Logik
async function initializeRingbuffer() {
    try {
        const currentTime = latestStudioTime || Date.now();
        const bufferDuration = bufferCapacity * 100; // 10min in ms
        const historyStart = currentTime - bufferDuration;
        
        const response = await fetch(`/api/history?from=${historyStart}&to=${currentTime}`);
        if (response.ok) {
            const data = await response.json();
            const points = Array.isArray(data) 
                ? data.map(normalizeHistoryPoint).filter(Boolean)
                : [];
            
            // Initialize buffer data with gaps
            ringbufferData = new Array(bufferCapacity).fill(null).map(() => ({
                l: 0, r: 0, silence: false,
                hasData: false,      // Ob hier jemals Daten waren
                fromCurrentPass: false
            }));
            
            // Sort points by time
            points.sort((a, b) => a.ts - b.ts);
            
            // Find the oldest and newest times
            if (points.length > 0) {
                const oldestTime = points[0].ts;
                const newestTime = points[points.length - 1].ts;
                
                // Calculate head position based on newest time
                bufferHeadIndex = Math.floor((newestTime / 100) % bufferCapacity);
                // Tail is 10min before head (or oldest data point)
                bufferTailIndex = Math.floor((oldestTime / 100) % bufferCapacity);
                
                // Mark all points and determine if they're in current pass
                // Current pass = points within the last 10min from head
                points.forEach(point => {
                    const bufferPos = Math.floor((point.ts / 100) % bufferCapacity);
                    
                    // Determine if this point is in current pass
                    // In ringbuffer: data from tail to head is current pass
                    let isCurrentPass;
                    if (bufferTailIndex <= bufferHeadIndex) {
                        // Normal case: tail <= head
                        isCurrentPass = bufferPos >= bufferTailIndex && bufferPos <= bufferHeadIndex;
                    } else {
                        // Wrap-around case: tail > head (buffer wrapped)
                        isCurrentPass = bufferPos >= bufferTailIndex || bufferPos <= bufferHeadIndex;
                    }
                    
                    const left = point.peaks[0] || 0;
                    const right = point.peaks[1] || 0;
                    
                    ringbufferData[bufferPos].l = left;
                    ringbufferData[bufferPos].r = right;
                    ringbufferData[bufferPos].silence = point.silence;
                    ringbufferData[bufferPos].hasData = true;
                    ringbufferData[bufferPos].fromCurrentPass = isCurrentPass;
                });
            }
            
            drawRingbuffer();
        }
    } catch (error) {
        console.error('Ringbuffer init failed:', error);
    }
}

function drawRingbuffer() {
    if (!ringbufferCtx || !ringbufferData) return;
    
    const width = ringbufferCanvas.width;
    const height = ringbufferCanvas.height;
    
    // Clear canvas
    ringbufferCtx.fillStyle = '#0d1117';
    ringbufferCtx.fillRect(0, 0, width, height);
    
    // Draw grid
    ringbufferCtx.strokeStyle = 'rgba(136, 136, 136, 0.1)';
    ringbufferCtx.lineWidth = 1;
    for (let i = 1; i < 10; i++) {
        const x = (width / 10) * i;
        ringbufferCtx.beginPath();
        ringbufferCtx.moveTo(x, 0);
        ringbufferCtx.lineTo(x, height);
        ringbufferCtx.stroke();
    }
    
    const midY = height / 2;
    
    // Draw all buffer positions
    for (let x = 0; x < width; x++) {
        const bufferIndex = Math.floor((x / width) * bufferCapacity);
        const point = ringbufferData[bufferIndex];
        
        if (!point.hasData) {
            // GAP - draw red background for missing data
            ringbufferCtx.fillStyle = 'rgba(231, 76, 60, 0.1)';
            ringbufferCtx.fillRect(x, 0, 1, height);
            continue;
        }
        
        const isCurrent = point.fromCurrentPass;
        
        const leftHeight = Math.min(point.l * height * 0.45, height / 2);
        const rightHeight = Math.min(point.r * height * 0.45, height / 2);
        
        // Left channel - CURRENT = kr√§ftig, PAST = matt
        ringbufferCtx.fillStyle = isCurrent 
            ? 'rgba(90, 160, 255, 0.8)'   // Aktuell: kr√§ftig
            : 'rgba(90, 160, 255, 0.2)';  // Vergangen: matt
        
        ringbufferCtx.fillRect(x, midY - leftHeight, 1, leftHeight);
        
        // Right channel
        ringbufferCtx.fillStyle = isCurrent
            ? 'rgba(155, 89, 182, 0.8)'   // Aktuell: kr√§ftig
            : 'rgba(155, 89, 182, 0.2)';  // Vergangen: matt
        
        ringbufferCtx.fillRect(x, midY, 1, rightHeight);
        
        // Silence overlay
        if (point.silence) {
            ringbufferCtx.fillStyle = isCurrent
                ? 'rgba(231, 76, 60, 0.3)'   // Aktuell
                : 'rgba(231, 76, 60, 0.1)';  // Vergangen
            ringbufferCtx.fillRect(x, 0, 1, height);
        }
    }
    
    // Draw markers
    const headX = (bufferHeadIndex / bufferCapacity) * width;
    const tailX = (bufferTailIndex / bufferCapacity) * width;
    
    const overlay = document.getElementById('ringbufferOverlay');
    overlay.innerHTML = `
        <div class="waveform-marker head" style="left: ${headX}px;"></div>
        <div class="waveform-marker tail" style="left: ${tailX}px;"></div>
    `;
    
    // Update info
    if (currentStatus?.ring) {
        const fillPercent = Math.round((currentStatus.ring.fill_ratio || 0) * 100);
        document.getElementById('ringbufferInfo').textContent = `F√ºllstand: ${fillPercent}%`;
    }
    
    // Time display
    const timeDisplay = document.getElementById('ringbufferTime');
    if (latestStudioTime) {
        const tenMinutesAgo = latestStudioTime - (10 * 60 * 1000);
        timeDisplay.textContent = `${formatTime(tenMinutesAgo)} - ${formatTime(latestStudioTime)}`;
    }
}

function updateRingbufferPoint(timestamp, peaks, silence) {
    if (!ringbufferData) return;
    
    // Calculate buffer position
    const bufferPos = Math.floor((timestamp / 100) % bufferCapacity);
    
    // Update buffer head position
    bufferHeadIndex = bufferPos;
    
    // Update tail position (10min before head)
    bufferTailIndex = (bufferHeadIndex + 1) % bufferCapacity;
    
    // Update buffer data
    const left = peaks[0] || 0;
    const right = peaks[1] || 0;
    
    ringbufferData[bufferPos].l = left;
    ringbufferData[bufferPos].r = right;
    ringbufferData[bufferPos].silence = silence;
    ringbufferData[bufferPos].hasData = true;
    ringbufferData[bufferPos].fromCurrentPass = true; // WS-Peaks sind immer aktuell
    
    lastPeakTime = timestamp;
    
    // Draw updated pixel
    drawRingbufferPixel(bufferPos);
}

function drawRingbufferPixel(bufferPos) {
    if (!ringbufferCtx || !ringbufferData) return;
    
    const width = ringbufferCanvas.width;
    const height = ringbufferCanvas.height;
    
    const x = Math.floor((bufferPos / bufferCapacity) * width);
    const point = ringbufferData[bufferPos];
    const midY = height / 2;
    
    // Clear old pixel
    ringbufferCtx.fillStyle = '#0d1117';
    ringbufferCtx.fillRect(x, 0, 1, height);
    
    if (!point.hasData) {
        // GAP
        ringbufferCtx.fillStyle = 'rgba(231, 76, 60, 0.1)';
        ringbufferCtx.fillRect(x, 0, 1, height);
        return;
    }
    
    const isCurrent = point.fromCurrentPass;
    const leftHeight = Math.min(point.l * height * 0.45, height / 2);
    const rightHeight = Math.min(point.r * height * 0.45, height / 2);
    
    // Left channel
    ringbufferCtx.fillStyle = isCurrent 
        ? 'rgba(90, 160, 255, 0.8)'
        : 'rgba(90, 160, 255, 0.2)';
    ringbufferCtx.fillRect(x, midY - leftHeight, 1, leftHeight);
    
    // Right channel
    ringbufferCtx.fillStyle = isCurrent
        ? 'rgba(155, 89, 182, 0.8)'
        : 'rgba(155, 89, 182, 0.2)';
    ringbufferCtx.fillRect(x, midY, 1, rightHeight);
    
    // Silence
    if (point.silence) {
        ringbufferCtx.fillStyle = isCurrent
            ? 'rgba(231, 76, 60, 0.3)'
            : 'rgba(231, 76, 60, 0.1)';
        ringbufferCtx.fillRect(x, 0, 1, height);
    }
    
    // Update markers
    const headX = (bufferHeadIndex / bufferCapacity) * width;
    const tailX = (bufferTailIndex / bufferCapacity) * width;
    
    const overlay = document.getElementById('ringbufferOverlay');
    overlay.innerHTML = `
        <div class="waveform-marker head" style="left: ${headX}px;"></div>
        <div class="waveform-marker tail" style="left: ${tailX}px;"></div>
    `;
}

// Recorder initialization and updates
async function initializeRecorder() {
    try {
        const currentHour = Math.floor(Date.now() / 1000 / 3600);
        const hourStart = currentHour * 3600 * 1000;
        const hourEnd = hourStart + 3600 * 1000;
        
        const response = await fetch(`/api/history?from=${hourStart}&to=${hourEnd}`);
        if (response.ok) {
            const data = await response.json();
            recorderData = Array.isArray(data) 
                ? data.map(normalizeHistoryPoint).filter(Boolean)
                : [];
            drawRecorder();
        }
    } catch (error) {
        console.error('Recorder init failed:', error);
    }
}

function drawRecorder() {
    if (!recorderCtx) return;
    
    const width = recorderCanvas.width;
    const height = recorderCanvas.height;
    
    // Clear
    recorderCtx.fillStyle = '#0d1117';
    recorderCtx.fillRect(0, 0, width, height);
    
    // Current hour
    const now = latestStudioTime || Date.now();
    const currentHour = Math.floor(now / 1000 / 3600);
    const hourStart = currentHour * 3600 * 1000;
    const hourEnd = hourStart + 3600 * 1000;
    
    // Progress
    const progress = Math.min(1, Math.max(0, (now - hourStart) / 3600000));
    const progressPercent = Math.round(progress * 100);
    document.getElementById('recorderProgress').textContent = `${progressPercent}%`;
    
    // Draw waveform
    const midY = height / 2;
    
    recorderData.forEach(point => {
        const pointProgress = (point.ts - hourStart) / 3600000;
        if (pointProgress < 0 || pointProgress > 1) return;
        
        const x = Math.floor(pointProgress * width);
        const left = point.peaks[0] || 0;
        const right = point.peaks[1] || 0;
        
        const leftHeight = Math.min(left * height * 0.45, height / 2);
        const rightHeight = Math.min(right * height * 0.45, height / 2);
        
        // Left channel
        recorderCtx.fillStyle = 'rgba(39, 174, 96, 0.8)';
        recorderCtx.fillRect(x, midY - leftHeight, 1, leftHeight);
        
        // Right channel
        recorderCtx.fillStyle = 'rgba(46, 204, 113, 0.8)';
        recorderCtx.fillRect(x, midY, 1, rightHeight);
    });
    
    // Time display
    const timeDisplay = document.getElementById('recorderTime');
    const hourDate = new Date(hourStart);
    const hourStr = hourDate.getHours().toString().padStart(2, '0');
    timeDisplay.textContent = `Stunde ${hourStr}:00 - ${formatTime(hourStart)} ‚Üí ${formatTime(hourEnd)}`;
}

function updateRecorder(timestamp, peaks, silence) {
    // Add to recorder data
    recorderData.push({
        ts: timestamp,
        peaks: peaks || [0, 0],
        silence: silence
    });
    
    // Keep only last hour
    const hourAgo = timestamp - 3600000;
    recorderData = recorderData.filter(p => p.ts >= hourAgo);
    
    // Redraw recorder
    drawRecorder();
}

// WebSocket - ohne Debug-Spam
function setupWebSocket() {
    const proto = location.protocol === 'https:' ? 'wss://' : 'ws://';
    const wsUrl = proto + window.location.host + '/ws';
    
    websocket = new WebSocket(wsUrl);
    
    websocket.onopen = () => {
        updateConnectionState(true);
    };
    
    websocket.onerror = (err) => {
        console.error('[WS] Error:', err);
        updateConnectionState(false);
    };
    
    websocket.onclose = () => {
        updateConnectionState(false);
        setTimeout(setupWebSocket, 5000);
    };
    
    websocket.onmessage = (e) => {
        try {
            const data = JSON.parse(e.data);
            wsMessageCount++;
            
            if (data && typeof data.timestamp === 'number') {
                latestStudioTime = data.timestamp;
                
                // Update studio time displays
                document.getElementById('studioTime').textContent = formatTime(latestStudioTime);
                document.getElementById('systemStudioTime').textContent = formatTime(latestStudioTime);
                
                // Update latency
                const latency = Date.now() - latestStudioTime;
                document.getElementById('systemLatency').textContent = `${Math.max(0, latency)}ms`;
                
                // Extract peaks
                let peaks = null;
                let silence = false;
                
                if (Array.isArray(data.peaks)) {
                    peaks = data.peaks;
                }
                
                if (data.silence !== undefined) {
                    silence = data.silence;
                }
                
                // Update ringbuffer with new peak
                if (peaks !== null || silence) {
                    updateRingbufferPoint(
                        data.timestamp,
                        peaks || [0, 0],
                        silence
                    );
                }
                
                // Update recorder
                updateRecorder(data.timestamp, peaks, silence);
                
                // Update timestamp
                document.getElementById('updateTime').textContent = formatTime(Date.now());
                
                // Auto-refresh every 10 WS messages (‚âà1 second)
                if (wsMessageCount % 10 === 0) {
                    refreshStatusData();
                }
            }
        } catch (err) {
            // Silent catch
        }
    };
}

// Periodic refresh of status data
function startAutoRefresh() {
    if (autoRefreshInterval) clearInterval(autoRefreshInterval);
    // Refresh every 30 seconds
    autoRefreshInterval = setInterval(refreshStatusData, 30000);
}

async function refreshStatusData() {
    try {
        const statusResponse = await fetch('/api/status');
        if (statusResponse.ok) {
            currentStatus = await statusResponse.json();
            updateUI(currentStatus);
            
            // Update buffer positions
            if (currentStatus.ring) {
                bufferCapacity = currentStatus.ring.capacity || 6000;
                // Only update head/tail if we have no recent WS data
                if (Date.now() - lastPeakTime > 5000) {
                    bufferHeadIndex = currentStatus.ring.head_index || 0;
                    bufferTailIndex = currentStatus.ring.tail_index || 0;
                }
            }
        }
    } catch (error) {
        // Silent error
    }
}

// UI Rendering functions
function updateConnectionState(connected) {
    const dot = document.querySelector('.conn-dot');
    const text = document.getElementById('connText');
    
    if (connected) {
        dot.className = 'conn-dot connected';
        text.textContent = 'Verbunden';
    } else {
        dot.className = 'conn-dot error';
        text.textContent = 'Getrennt';
    }
}

function renderModulesTable(status) {
    const modules = status.modules || [];
    const countElement = document.getElementById('activeModulesCount');
    const table = document.getElementById('modulesTable');
    
    countElement.textContent = modules.length;
    
    if (modules.length === 0) {
        table.innerHTML = `
            <tbody>
                <tr>
                    <td colspan="4" class="empty-state">
                        <div class="icon">üì¶</div>
                        <div class="message">Keine aktiven Module</div>
                    </td>
                </tr>
            </tbody>`;
        return;
    }
    
    let html = '<tbody>';
    modules.forEach(module => {
        html += `
            <tr>
                <td>
                    <div style="font-weight: 600;">${module.label}</div>
                    <div style="font-family: monospace; font-size: 10px; color: #888;">${module.id}</div>
                </td>
                <td>
                    <span style="display: inline-block; padding: 2px 6px; border-radius: 4px; font-size: 10px; background: var(--${module.module_type}); color: white;">
                        ${module.module_type}
                    </span>
                </td>
                <td>
                    <div style="display: flex; align-items: center; gap: 6px;">
                        <span class="status-dot ${module.runtime.enabled ? 'active' : 'inactive'}"></span>
                        <span>${module.runtime.enabled ? 'Aktiv' : 'Inaktiv'}</span>
                    </div>
                </td>
                <td>
                    <div style="font-family: monospace; font-size: 11px;">
                        <div>RX: ${module.runtime.counters.rx}</div>
                        <div>TX: ${module.runtime.counters.tx}</div>
                    </div>
                </td>
            </tr>
        `;
    });
    html += '</tbody>';
    table.innerHTML = html;
}

function renderInactiveModules(status) {
    const inactive = status.inactive_modules || [];
    const countElement = document.getElementById('inactiveModulesCount');
    const table = document.getElementById('inactiveModulesTable');
    
    countElement.textContent = inactive.length;
    
    if (inactive.length === 0) {
        table.innerHTML = `
            <tbody>
                <tr>
                    <td colspan="4" class="empty-state">
                        <div class="icon">üîå</div>
                        <div class="message">Keine inaktiven Module</div>
                    </td>
                </tr>
            </tbody>`;
        return;
    }
    
    let html = '<tbody>';
    inactive.forEach(module => {
        html += `
            <tr>
                <td>
                    <div style="font-weight: 600;">${module.label}</div>
                    <div style="font-family: monospace; font-size: 10px; color: #888;">${module.id}</div>
                </td>
                <td>
                    <span style="display: inline-block; padding: 2px 6px; border-radius: 4px; font-size: 10px; background: var(--${module.module_type}); color: white;">
                        ${module.module_type}
                    </span>
                </td>
                <td>
                    <div style="display: flex; align-items: center; gap: 6px;">
                        <span class="status-dot inactive"></span>
                        <span>Inaktiv</span>
                    </div>
                </td>
                <td>
                    <span style="font-size: 11px; color: #888;">${module.reason}</span>
                </td>
            </tr>
        `;
    });
    html += '</tbody>';
    table.innerHTML = html;
}

function renderControls(status) {
    const container = document.getElementById('controlsGrid');
    const allControls = [];
    
    if (status.modules) {
        status.modules.forEach(module => {
            if (module.controls) {
                module.controls.forEach(control => {
                    if (!allControls.some(c => c.action === control.action)) {
                        allControls.push(control);
                    }
                });
            }
        });
    }
    
    if (allControls.length === 0) {
        container.innerHTML = '<button class="btn" disabled>Keine Steuerung</button>';
        return;
    }
    
    container.innerHTML = allControls.map(control => `
        <button class="btn ${control.enabled ? 'primary' : ''}"
                onclick="sendControl('${control.action}')"
                ${!control.enabled ? 'disabled' : ''}
                title="${control.reason || ''}">
            ${control.label}
        </button>
    `).join('');
}

function renderCodecs(codecs) {
    const container = document.getElementById('codecsList');
    
    if (!codecs || codecs.length === 0) {
        container.innerHTML = '<div class="empty-state">Keine Codecs verf√ºgbar</div>';
        return;
    }
    
    container.innerHTML = codecs.map(codec => `
        <div class="codec-item">
            <div class="codec-status">
                <span class="status-dot ${codec.runtime_state.enabled ? 'active' : 'inactive'}"></span>
            </div>
            <div class="codec-info">
                <div class="codec-name">${codec.id}</div>
                <div class="codec-details">${codec.codec_type} @ ${codec.config.sample_rate}Hz</div>
            </div>
        </div>
    `).join('');
}

function renderAudioPipeline(status) {
    const container = document.getElementById('pipelineTree');
    
    if (!status.graph || !status.graph.nodes || status.graph.nodes.length === 0) {
        container.innerHTML = `
            <div class="empty-state">
                <div class="icon">üîá</div>
                <div class="message">Keine aktiven Module in Pipeline</div>
            </div>`;
        return;
    }
    
    // Simplified pipeline view
    container.innerHTML = '<div style="color: #888; font-size: 12px;">Pipeline-Darstellung wird geladen...</div>';
}

// Main initialization
async function initializeAll() {
    try {
        initCanvases();
        
        // Load initial status
        const statusResponse = await fetch('/api/status');
        if (!statusResponse.ok) throw new Error('Status API failed');
        
        currentStatus = await statusResponse.json();
        
        // Update buffer positions from status
        if (currentStatus.ring) {
            bufferCapacity = currentStatus.ring.capacity || 6000;
            bufferHeadIndex = currentStatus.ring.head_index || 0;
            bufferTailIndex = currentStatus.ring.tail_index || 0;
        }
        
        // Update UI
        updateUI(currentStatus);
        
        // Load codecs
        try {
            const codecsResponse = await fetch('/api/codecs');
            if (codecsResponse.ok) {
                const codecs = await codecsResponse.json();
                renderCodecs(codecs);
            }
        } catch (e) { /* ignore */ }
        
        // Initialize ringbuffer and recorder
        await Promise.all([
            initializeRingbuffer(),
            initializeRecorder()
        ]);
        
        // Setup WebSocket
        setupWebSocket();
        
        // Start auto-refresh
        startAutoRefresh();
        
        updateConnectionState(true);
        
    } catch (error) {
        console.error('Initialization failed:', error);
        updateConnectionState(false);
    }
}

function updateUI(status) {
    currentStatus = status;
    
    // Update timestamp
    document.getElementById('updateTime').textContent = formatTime(Date.now());
    
    // Render modules
    renderModulesTable(status);
    renderInactiveModules(status);
    renderControls(status);
    renderAudioPipeline(status);
    
    // Update system stats
    if (status.ring) {
        const fillPercent = Math.round((status.ring.fill_ratio || 0) * 100);
        document.getElementById('ringbufferInfo').textContent = `F√ºllstand: ${fillPercent}%`;
        
        const bufferDuration = (status.ring.capacity || 6000) * 100 / 1000;
        document.getElementById('systemAudioBuffer').textContent = `${bufferDuration}s`;
    }
}

async function refreshAllData() {
    try {
        const [statusResponse, codecsResponse] = await Promise.all([
            fetch('/api/status'),
            fetch('/api/codecs')
        ]);
        
        if (statusResponse.ok) {
            currentStatus = await statusResponse.json();
            updateUI(currentStatus);
        }
        
        if (codecsResponse.ok) {
            const codecs = await codecsResponse.json();
            renderCodecs(codecs);
        }
        
        // Reinitialize with fresh history
        await Promise.all([
            initializeRingbuffer(),
            initializeRecorder()
        ]);
        
    } catch (error) {
        console.error('Refresh failed:', error);
    }
}

async function sendControl(action) {
    try {
        const response = await fetch('/api/control', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ action })
        });
        
        if (response.ok) {
            setTimeout(refreshStatusData, 500);
        }
        
    } catch (error) {
        console.error('Control action failed:', error);
    }
}

// Start everything
document.addEventListener('DOMContentLoaded', initializeAll);
</script>
</body>
</html>
